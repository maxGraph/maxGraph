

<!DOCTYPE html>
<html lang="en">

<head>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title> view/handler/EdgeHandler.ts</title>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="./build/entry.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,400,700|Inconsolata,700" rel="stylesheet">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
  <link type="text/css" rel="stylesheet" href="styles/app.min.css">
  <link type="text/css" rel="stylesheet" href="styles/iframe.css">
  <link type="text/css" rel="stylesheet" href="">
  <script async defer src="https://buttons.github.io/buttons.js"></script>

  
</head>



<body class="layout small-header">
    <div id="stickyNavbarOverlay"></div>
    

<div class="top-nav">
    <div class="inner">
        <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
        <div class="logo">
            
            
        </div>
        <div class="menu">
            
            <div class="navigation">
                <a
                    href="index.html"
                    class="link"
                >
                    API Documentation
                </a>
                
                
                
            </div>
        </div>
    </div>
</div>
    <div id="main">
        <div
            class="sidebar "
            id="sidebarNav"
        >
            
                <div class="search-wrapper">
                    <input id="search" type="text" placeholder="Search docs..." class="input">
                </div>
            
            <nav>
                
                    <h2><a href="index.html">Documentation</a></h2><div class="category"><h3>Classes</h3><ul><li><a href="AbstractCanvas2D.html">AbstractCanvas2D</a></li><li><a href="ActorShape.html">ActorShape</a></li><li><a href="Animation.html">Animation</a></li><li><a href="ArrowConnectorShape.html">ArrowConnectorShape</a></li><li><a href="ArrowShape.html">ArrowShape</a></li><li><a href="AutoSaveManager.html">AutoSaveManager</a></li><li><a href="Cell.html">Cell</a></li><li><a href="CellAttributeChange.html">CellAttributeChange</a></li><li><a href="CellCodec.html">CellCodec</a></li><li><a href="CellEditorHandler.html">CellEditorHandler</a></li><li><a href="CellHighlight.html">CellHighlight</a></li><li><a href="CellMarker.html">CellMarker</a></li><li><a href="CellOverlay.html">CellOverlay</a></li><li><a href="CellPath.html">CellPath</a></li><li><a href="CellRenderer.html">CellRenderer</a></li><li><a href="CellState.html">CellState</a></li><li><a href="CellStatePreview.html">CellStatePreview</a></li><li><a href="CellTracker.html">CellTracker</a></li><li><a href="ChildChange.html">ChildChange</a></li><li><a href="ChildChangeCodec.html">ChildChangeCodec</a></li><li><a href="CircleLayout.html">CircleLayout</a></li><li><a href="Client.html">Client</a></li><li><a href="Clipboard.html">Clipboard</a></li><li><a href="CloudShape.html">CloudShape</a></li><li><a href="Codec.html">Codec</a></li><li><a href="CodecRegistry.html">CodecRegistry</a></li><li><a href="CollapseChange.html">CollapseChange</a></li><li><a href="CompactTreeLayout.html">CompactTreeLayout</a></li><li><a href="CompositeLayout.html">CompositeLayout</a></li><li><a href="ConnectionConstraint.html">ConnectionConstraint</a></li><li><a href="ConnectionHandler.html">ConnectionHandler</a></li><li><a href="ConnectorShape.html">ConnectorShape</a></li><li><a href="ConstraintHandler.html">ConstraintHandler</a></li><li><a href="CoordinateAssignment.html">CoordinateAssignment</a></li><li><a href="CurrentRootChange.html">CurrentRootChange</a></li><li><a href="CylinderShape.html">CylinderShape</a></li><li><a href="Dictionary.html">Dictionary</a></li><li><a href="DoubleEllipseShape.html">DoubleEllipseShape</a></li><li><a href="DragSource.html">DragSource</a></li><li><a href="EdgeHandler.html">EdgeHandler</a></li><li><a href="EdgeLabelLayout.html">EdgeLabelLayout</a></li><li><a href="EdgeStyle.html">EdgeStyle</a></li><li><a href="Editor.html">Editor</a></li><li><a href="EditorCodec.html">EditorCodec</a></li><li><a href="EditorKeyHandler.html">EditorKeyHandler</a></li><li><a href="EditorKeyHandlerCodec.html">EditorKeyHandlerCodec</a></li><li><a href="EditorPopupMenu.html">EditorPopupMenu</a></li><li><a href="EditorPopupMenuCodec.html">EditorPopupMenuCodec</a></li><li><a href="EditorToolbar.html">EditorToolbar</a></li><li><a href="EditorToolbarCodec.html">EditorToolbarCodec</a></li><li><a href="Effects.html">Effects</a></li><li><a href="ElbowEdgeHandler.html">ElbowEdgeHandler</a></li><li><a href="EllipseShape.html">EllipseShape</a></li><li><a href="EventObject.html">EventObject</a></li><li><a href="EventSource.html">EventSource</a></li><li><a href="GenericChangeCodec.html">GenericChangeCodec</a></li><li><a href="Geometry.html">Geometry</a></li><li><a href="GeometryChange.html">GeometryChange</a></li><li><a href="graph.html">graph</a></li><li><a href="GraphAbstractHierarchyCell.html">GraphAbstractHierarchyCell</a></li><li><a href="GraphCodec.html">GraphCodec</a></li><li><a href="GraphHierarchyEdge.html">GraphHierarchyEdge</a></li><li><a href="GraphHierarchyModel.html">GraphHierarchyModel</a></li><li><a href="GraphHierarchyNode.html">GraphHierarchyNode</a></li><li><a href="GraphLayout.html">GraphLayout</a></li><li><a href="GraphView.html">GraphView</a></li><li><a href="GraphViewCodec.html">GraphViewCodec</a></li><li><a href="Guide.html">Guide</a></li><li><a href="HexagonShape.html">HexagonShape</a></li><li><a href="HierarchicalLayout.html">HierarchicalLayout</a></li><li><a href="HierarchicalLayoutStage.html">HierarchicalLayoutStage</a></li><li><a href="ImageBox.html">ImageBox</a></li><li><a href="ImageBundle.html">ImageBundle</a></li><li><a href="ImageExport.html">ImageExport</a></li><li><a href="ImageShape.html">ImageShape</a></li><li><a href="InternalEvent.html">InternalEvent</a></li><li><a href="InternalMouseEvent.html">InternalMouseEvent</a></li><li><a href="KeyHandler.html">KeyHandler</a></li><li><a href="LabelShape.html">LabelShape</a></li><li><a href="LayoutManager.html">LayoutManager</a></li><li><a href="Line.html">Line</a></li><li><a href="MarkerShape.html">MarkerShape</a></li><li><a href="MaxForm.html">MaxForm</a></li><li><a href="MaxLog.html">MaxLog</a></li><li><a href="MaxPopupMenu.html">MaxPopupMenu</a></li><li><a href="MaxToolbar.html">MaxToolbar</a></li><li><a href="MaxWindow.html">MaxWindow</a></li><li><a href="MaxXmlRequest.html">MaxXmlRequest</a></li><li><a href="MedianCellSorter.html">MedianCellSorter</a></li><li><a href="MedianHybridCrossingReduction.html">MedianHybridCrossingReduction</a></li><li><a href="MinimumCycleRemover.html">MinimumCycleRemover</a></li><li><a href="Model.html">Model</a></li><li><a href="ModelCodec.html">ModelCodec</a></li><li><a href="Morphing.html">Morphing</a></li><li><a href="Multiplicity.html">Multiplicity</a></li><li><a href="MxFastOrganicLayout.html">MxFastOrganicLayout</a></li><li><a href="mxXmlCanvas2D.html">mxXmlCanvas2D</a></li><li><a href="ObjectCodec.html">ObjectCodec</a></li><li><a href="ObjectIdentity.html">ObjectIdentity</a></li><li><a href="Outline.html">Outline</a></li><li><a href="PanningHandler.html">PanningHandler</a></li><li><a href="PanningManager.html">PanningManager</a></li><li><a href="ParallelEdgeLayout.html">ParallelEdgeLayout</a></li><li><a href="PartitionLayout.html">PartitionLayout</a></li><li><a href="Perimeter.html">Perimeter</a></li><li><a href="Point.html">Point</a></li><li><a href="PolylineShape.html">PolylineShape</a></li><li><a href="PopupMenuHandler.html">PopupMenuHandler</a></li><li><a href="PrintPreview.html">PrintPreview</a></li><li><a href="RadialTreeLayout.html">RadialTreeLayout</a></li><li><a href="Rectangle.html">Rectangle</a></li><li><a href="RectangleShape.html">RectangleShape</a></li><li><a href="RhombusShape.html">RhombusShape</a></li><li><a href="RootChange.html">RootChange</a></li><li><a href="RootChangeCodec.html">RootChangeCodec</a></li><li><a href="RubberBandHandler.html">RubberBandHandler</a></li><li><a href="SelectionCellsHandler.html">SelectionCellsHandler</a></li><li><a href="SelectionChange.html">SelectionChange</a></li><li><a href="SelectionHandler.html">SelectionHandler</a></li><li><a href="Shape.html">Shape</a></li><li><a href="StackLayout.html">StackLayout</a></li><li><a href="StencilShape.html">StencilShape</a></li><li><a href="StencilShapeRegistry.html">StencilShapeRegistry</a></li><li><a href="StyleChange.html">StyleChange</a></li><li><a href="StyleRegistry.html">StyleRegistry</a></li><li><a href="Stylesheet.html">Stylesheet</a></li><li><a href="StylesheetCodec.html">StylesheetCodec</a></li><li><a href="SvgCanvas2D.html">SvgCanvas2D</a></li><li><a href="SwimlaneLayout.html">SwimlaneLayout</a></li><li><a href="SwimlaneManager.html">SwimlaneManager</a></li><li><a href="SwimlaneModel.html">SwimlaneModel</a></li><li><a href="SwimlaneOrdering.html">SwimlaneOrdering</a></li><li><a href="SwimlaneShape.html">SwimlaneShape</a></li><li><a href="TerminalChange.html">TerminalChange</a></li><li><a href="TerminalChangeCodec.html">TerminalChangeCodec</a></li><li><a href="TextShape.html">TextShape</a></li><li><a href="TooltipHandler.html">TooltipHandler</a></li><li><a href="Translations.html">Translations</a></li><li><a href="TriangleShape.html">TriangleShape</a></li><li><a href="UndoableEdit.html">UndoableEdit</a></li><li><a href="UndoManager.html">UndoManager</a></li><li><a href="UrlConverter.html">UrlConverter</a></li><li><a href="ValueChange.html">ValueChange</a></li><li><a href="VertexHandle.html">VertexHandle</a></li><li><a href="VertexHandler.html">VertexHandler</a></li><li><a href="VisibleChange.html">VisibleChange</a></li></ul><h3>Global</h3><ul><li><a href="global.html#ABSOLUTE_LINE_HEIGHT">ABSOLUTE_LINE_HEIGHT</a></li><li><a href="global.html#addStylename">addStylename</a></li><li><a href="global.html#ALIGN">ALIGN</a></li><li><a href="global.html#arcToCurves">arcToCurves</a></li><li><a href="global.html#ARROW">ARROW</a></li><li><a href="global.html#ARROW_SIZE">ARROW_SIZE</a></li><li><a href="global.html#ARROW_SPACING">ARROW_SPACING</a></li><li><a href="global.html#ARROW_WIDTH">ARROW_WIDTH</a></li><li><a href="global.html#br">br</a></li><li><a href="global.html#button">button</a></li><li><a href="global.html#clearSelection">clearSelection</a></li><li><a href="global.html#clone">clone</a></li><li><a href="global.html#CONNECT_HANDLE_FILLCOLOR">CONNECT_HANDLE_FILLCOLOR</a></li><li><a href="global.html#CONNECT_TARGET_COLOR">CONNECT_TARGET_COLOR</a></li><li><a href="global.html#contains">contains</a></li><li><a href="global.html#convertPoint">convertPoint</a></li><li><a href="global.html#createImage">createImage</a></li><li><a href="global.html#createXmlDocument">createXmlDocument</a></li><li><a href="global.html#CURSOR">CURSOR</a></li><li><a href="global.html#DEFAULT_FONTFAMILY">DEFAULT_FONTFAMILY</a></li><li><a href="global.html#DEFAULT_FONTSIZE">DEFAULT_FONTSIZE</a></li><li><a href="global.html#DEFAULT_FONTSTYLE">DEFAULT_FONTSTYLE</a></li><li><a href="global.html#DEFAULT_HOTSPOT">DEFAULT_HOTSPOT</a></li><li><a href="global.html#DEFAULT_IMAGESIZE">DEFAULT_IMAGESIZE</a></li><li><a href="global.html#DEFAULT_INVALID_COLOR">DEFAULT_INVALID_COLOR</a></li><li><a href="global.html#DEFAULT_MARKERSIZE">DEFAULT_MARKERSIZE</a></li><li><a href="global.html#DEFAULT_STARTSIZE">DEFAULT_STARTSIZE</a></li><li><a href="global.html#DEFAULT_TEXT_DIRECTION">DEFAULT_TEXT_DIRECTION</a></li><li><a href="global.html#DEFAULT_VALID_COLOR">DEFAULT_VALID_COLOR</a></li><li><a href="global.html#DIALECT">DIALECT</a></li><li><a href="global.html#DIRECTION_MASK">DIRECTION_MASK</a></li><li><a href="global.html#DROP_TARGET_COLOR">DROP_TARGET_COLOR</a></li><li><a href="global.html#EDGE_SELECTION_COLOR">EDGE_SELECTION_COLOR</a></li><li><a href="global.html#EDGE_SELECTION_DASHED">EDGE_SELECTION_DASHED</a></li><li><a href="global.html#EDGE_SELECTION_STROKEWIDTH">EDGE_SELECTION_STROKEWIDTH</a></li><li><a href="global.html#EDGESTYLE">EDGESTYLE</a></li><li><a href="global.html#ELBOW">ELBOW</a></li><li><a href="global.html#ENTITY_SEGMENT">ENTITY_SEGMENT</a></li><li><a href="global.html#equalEntries">equalEntries</a></li><li><a href="global.html#equalPoints">equalPoints</a></li><li><a href="global.html#error">error</a></li><li><a href="global.html#extractTextWithWhitespace">extractTextWithWhitespace</a></li><li><a href="global.html#findNearestSegment">findNearestSegment</a></li><li><a href="global.html#findNode">findNode</a></li><li><a href="global.html#findTreeRoots">findTreeRoots</a></li><li><a href="global.html#fit">fit</a></li><li><a href="global.html#FONT">FONT</a></li><li><a href="global.html#get">get</a></li><li><a href="global.html#getAlignmentAsPoint">getAlignmentAsPoint</a></li><li><a href="global.html#getAll">getAll</a></li><li><a href="global.html#getBoundingBox">getBoundingBox</a></li><li><a href="global.html#getChildNodes">getChildNodes</a></li><li><a href="global.html#getClientX">getClientX</a></li><li><a href="global.html#getClientY">getClientY</a></li><li><a href="global.html#getColor">getColor</a></li><li><a href="global.html#getCurrentStyle">getCurrentStyle</a></li><li><a href="global.html#getDirectedBounds">getDirectedBounds</a></li><li><a href="global.html#getDocumentScrollOrigin">getDocumentScrollOrigin</a></li><li><a href="global.html#getDocumentSize">getDocumentSize</a></li><li><a href="global.html#getFunctionName">getFunctionName</a></li><li><a href="global.html#getInnerHtml">getInnerHtml</a></li><li><a href="global.html#getNumber">getNumber</a></li><li><a href="global.html#getOffset">getOffset</a></li><li><a href="global.html#getOuterHtml">getOuterHtml</a></li><li><a href="global.html#getPerimeterPoint">getPerimeterPoint</a></li><li><a href="global.html#getPortConstraints">getPortConstraints</a></li><li><a href="global.html#getPrettyXml">getPrettyXml</a></li><li><a href="global.html#getRotatedPoint">getRotatedPoint</a></li><li><a href="global.html#getScaleForPageCount">getScaleForPageCount</a></li><li><a href="global.html#getScrollOrigin">getScrollOrigin</a></li><li><a href="global.html#getSizeForString">getSizeForString</a></li><li><a href="global.html#getSource">getSource</a></li><li><a href="global.html#getStylename">getStylename</a></li><li><a href="global.html#getStylenames">getStylenames</a></li><li><a href="global.html#getTextContent">getTextContent</a></li><li><a href="global.html#getValue">getValue</a></li><li><a href="global.html#getXml">getXml</a></li><li><a href="global.html#GUIDE_COLOR">GUIDE_COLOR</a></li><li><a href="global.html#GUIDE_STROKEWIDTH">GUIDE_STROKEWIDTH</a></li><li><a href="global.html#HANDLE_FILLCOLOR">HANDLE_FILLCOLOR</a></li><li><a href="global.html#HANDLE_SIZE">HANDLE_SIZE</a></li><li><a href="global.html#HANDLE_STROKECOLOR">HANDLE_STROKECOLOR</a></li><li><a href="global.html#hasScrollbars">hasScrollbars</a></li><li><a href="global.html#HIGHLIGHT_COLOR">HIGHLIGHT_COLOR</a></li><li><a href="global.html#HIGHLIGHT_OPACITY">HIGHLIGHT_OPACITY</a></li><li><a href="global.html#HIGHLIGHT_SIZE">HIGHLIGHT_SIZE</a></li><li><a href="global.html#HIGHLIGHT_STROKEWIDTH">HIGHLIGHT_STROKEWIDTH</a></li><li><a href="global.html#htmlEntities">htmlEntities</a></li><li><a href="global.html#importNode">importNode</a></li><li><a href="global.html#importNodeImplementation">importNodeImplementation</a></li><li><a href="global.html#indexOfStylename">indexOfStylename</a></li><li><a href="global.html#intersection">intersection</a></li><li><a href="global.html#intersects">intersects</a></li><li><a href="global.html#intersectsHotspot">intersectsHotspot</a></li><li><a href="global.html#INVALID_COLOR">INVALID_COLOR</a></li><li><a href="global.html#INVALID_CONNECT_TARGET_COLOR">INVALID_CONNECT_TARGET_COLOR</a></li><li><a href="global.html#isAltDown">isAltDown</a></li><li><a href="global.html#isAncestorNode">isAncestorNode</a></li><li><a href="global.html#isConsumed">isConsumed</a></li><li><a href="global.html#isControlDown">isControlDown</a></li><li><a href="global.html#isInteger">isInteger</a></li><li><a href="global.html#isLeftMouseButton">isLeftMouseButton</a></li><li><a href="global.html#isMetaDown">isMetaDown</a></li><li><a href="global.html#isMiddleMouseButton">isMiddleMouseButton</a></li><li><a href="global.html#isMouseEvent">isMouseEvent</a></li><li><a href="global.html#isMultiTouchEvent">isMultiTouchEvent</a></li><li><a href="global.html#isNode">isNode</a></li><li><a href="global.html#isNumeric">isNumeric</a></li><li><a href="global.html#isPenEvent">isPenEvent</a></li><li><a href="global.html#isPopupTrigger">isPopupTrigger</a></li><li><a href="global.html#isRightMouseButton">isRightMouseButton</a></li><li><a href="global.html#isShiftDown">isShiftDown</a></li><li><a href="global.html#isTouchEvent">isTouchEvent</a></li><li><a href="global.html#LABEL_HANDLE_FILLCOLOR">LABEL_HANDLE_FILLCOLOR</a></li><li><a href="global.html#LABEL_HANDLE_SIZE">LABEL_HANDLE_SIZE</a></li><li><a href="global.html#LINE_ARCSIZE">LINE_ARCSIZE</a></li><li><a href="global.html#LINE_HEIGHT">LINE_HEIGHT</a></li><li><a href="global.html#link">link</a></li><li><a href="global.html#linkAction">linkAction</a></li><li><a href="global.html#linkInvoke">linkInvoke</a></li><li><a href="global.html#load">load</a></li><li><a href="global.html#LOCKED_HANDLE_FILLCOLOR">LOCKED_HANDLE_FILLCOLOR</a></li><li><a href="global.html#ltrim">ltrim</a></li><li><a href="global.html#makeDraggable">makeDraggable</a></li><li><a href="global.html#MAX_HOTSPOT_SIZE">MAX_HOTSPOT_SIZE</a></li><li><a href="global.html#MIN_HOTSPOT_SIZE">MIN_HOTSPOT_SIZE</a></li><li><a href="global.html#mod">mod</a></li><li><a href="global.html#NONE">NONE</a></li><li><a href="global.html#NS_SVG">NS_SVG</a></li><li><a href="global.html#NS_XLINK">NS_XLINK</a></li><li><a href="global.html#OUTLINE_COLOR">OUTLINE_COLOR</a></li><li><a href="global.html#OUTLINE_HANDLE_FILLCOLOR">OUTLINE_HANDLE_FILLCOLOR</a></li><li><a href="global.html#OUTLINE_HANDLE_STROKECOLOR">OUTLINE_HANDLE_STROKECOLOR</a></li><li><a href="global.html#OUTLINE_HIGHLIGHT_COLOR">OUTLINE_HIGHLIGHT_COLOR</a></li><li><a href="global.html#OUTLINE_HIGHLIGHT_STROKEWIDTH">OUTLINE_HIGHLIGHT_STROKEWIDTH</a></li><li><a href="global.html#OUTLINE_STROKEWIDTH">OUTLINE_STROKEWIDTH</a></li><li><a href="global.html#PAGE_FORMAT_A4_LANDSCAPE">PAGE_FORMAT_A4_LANDSCAPE</a></li><li><a href="global.html#PAGE_FORMAT_A4_PORTRAIT">PAGE_FORMAT_A4_PORTRAIT</a></li><li><a href="global.html#PAGE_FORMAT_LETTER_LANDSCAPE">PAGE_FORMAT_LETTER_LANDSCAPE</a></li><li><a href="global.html#PAGE_FORMAT_LETTER_PORTRAIT">PAGE_FORMAT_LETTER_PORTRAIT</a></li><li><a href="global.html#para">para</a></li><li><a href="global.html#parseCssNumber">parseCssNumber</a></li><li><a href="global.html#PERIMETER">PERIMETER</a></li><li><a href="global.html#popup">popup</a></li><li><a href="global.html#post">post</a></li><li><a href="global.html#printScreen">printScreen</a></li><li><a href="global.html#ptLineDist">ptLineDist</a></li><li><a href="global.html#ptSegDistSq">ptSegDistSq</a></li><li><a href="global.html#RECTANGLE_ROUNDING_FACTOR">RECTANGLE_ROUNDING_FACTOR</a></li><li><a href="global.html#rectangleIntersectsSegment">rectangleIntersectsSegment</a></li><li><a href="global.html#relativeCcw">relativeCcw</a></li><li><a href="global.html#remove">remove</a></li><li><a href="global.html#removeAllStylenames">removeAllStylenames</a></li><li><a href="global.html#removeCursors">removeCursors</a></li><li><a href="global.html#removeDuplicates">removeDuplicates</a></li><li><a href="global.html#removeStylename">removeStylename</a></li><li><a href="global.html#removeWhitespace">removeWhitespace</a></li><li><a href="global.html#RENDERING_HINT">RENDERING_HINT</a></li><li><a href="global.html#replaceTrailingNewlines">replaceTrailingNewlines</a></li><li><a href="global.html#reversePortConstraints">reversePortConstraints</a></li><li><a href="global.html#rtrim">rtrim</a></li><li><a href="global.html#setCellStyleFlags">setCellStyleFlags</a></li><li><a href="global.html#setCellStyles">setCellStyles</a></li><li><a href="global.html#setOpacity">setOpacity</a></li><li><a href="global.html#setPrefixedStyle">setPrefixedStyle</a></li><li><a href="global.html#setStyle">setStyle</a></li><li><a href="global.html#setStyleFlag">setStyleFlag</a></li><li><a href="global.html#setTextContent">setTextContent</a></li><li><a href="global.html#SHADOW_OFFSET_X">SHADOW_OFFSET_X</a></li><li><a href="global.html#SHADOW_OFFSET_Y">SHADOW_OFFSET_Y</a></li><li><a href="global.html#SHADOW_OPACITY">SHADOW_OPACITY</a></li><li><a href="global.html#SHADOWCOLOR">SHADOWCOLOR</a></li><li><a href="global.html#show">show</a></li><li><a href="global.html#sortCells">sortCells</a></li><li><a href="global.html#submit">submit</a></li><li><a href="global.html#TEXT_DIRECTION">TEXT_DIRECTION</a></li><li><a href="global.html#toDegree">toDegree</a></li><li><a href="global.html#TOOLTIP_VERTICAL_OFFSET">TOOLTIP_VERTICAL_OFFSET</a></li><li><a href="global.html#toRadians">toRadians</a></li><li><a href="global.html#toString">toString</a></li><li><a href="global.html#traverse">traverse</a></li><li><a href="global.html#trim">trim</a></li><li><a href="global.html#utils">utils</a></li><li><a href="global.html#VALID_COLOR">VALID_COLOR</a></li><li><a href="global.html#VERTEX_SELECTION_COLOR">VERTEX_SELECTION_COLOR</a></li><li><a href="global.html#VERTEX_SELECTION_DASHED">VERTEX_SELECTION_DASHED</a></li><li><a href="global.html#VERTEX_SELECTION_STROKEWIDTH">VERTEX_SELECTION_STROKEWIDTH</a></li><li><a href="global.html#WORD_WRAP">WORD_WRAP</a></li><li><a href="global.html#write">write</a></li><li><a href="global.html#writeln">writeln</a></li></ul></div>
                
            </nav>
        </div>
        <div class="core" id="main-content-wrapper">
            <div class="content">
                <header class="page-title">
                    <p>Source</p>
                    <h1>view/handler/EdgeHandler.ts</h1>
                </header>
                



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Copyright (c) 2006-2015, JGraph Ltd
 * Copyright (c) 2006-2015, Gaudenz Alder
 * Updated to ES9 syntax by David Morrissey 2021
 * Type definitions from the typed-mxgraph project
 */
import CellMarker from '../cell/CellMarker';
import Point from '../geometry/Point';
import {
  CONNECT_HANDLE_FILLCOLOR,
  CURSOR,
  DEFAULT_VALID_COLOR,
  DIALECT,
  EDGE_SELECTION_COLOR,
  EDGE_SELECTION_DASHED,
  EDGE_SELECTION_STROKEWIDTH,
  HANDLE_FILLCOLOR,
  HANDLE_SIZE,
  HANDLE_STROKECOLOR,
  HIGHLIGHT_STROKEWIDTH,
  LABEL_HANDLE_FILLCOLOR,
  LABEL_HANDLE_SIZE,
  LOCKED_HANDLE_FILLCOLOR,
  NONE,
  OUTLINE_HIGHLIGHT_COLOR,
  OUTLINE_HIGHLIGHT_STROKEWIDTH,
} from '../../util/constants';
import {
  contains,
  findNearestSegment,
  intersects,
  ptSegDistSq,
} from '../../util/mathUtils';
import {
  convertPoint,
  getOffset,
  setOpacity,
} from '../../util/styleUtils';
import ImageShape from '../geometry/node/ImageShape';
import RectangleShape from '../geometry/node/RectangleShape';
import ConnectionConstraint from '../other/ConnectionConstraint';
import InternalEvent from '../event/InternalEvent';
import ConstraintHandler from './ConstraintHandler';
import Rectangle from '../geometry/Rectangle';
import Client from '../../Client';
import EdgeStyle from '../style/EdgeStyle';
import {
  getClientX,
  getClientY,
  isAltDown,
  isMouseEvent,
  isShiftDown,
} from '../../util/eventUtils';
import { Graph } from '../Graph';
import CellState from '../cell/CellState';
import Shape from '../geometry/Shape';
import { CellHandle, ColorValue, Listenable } from '../../types';
import InternalMouseEvent from '../event/InternalMouseEvent';
import Cell from '../cell/Cell';
import ImageBox from '../image/ImageBox';
import EventSource from '../event/EventSource';
import SelectionHandler from './SelectionHandler';
import { equalPoints } from '../../util/arrayUtils';

/**
 * Graph event handler that reconnects edges and modifies control points and the edge
 * label location.
 * Uses &lt;mxTerminalMarker> for finding and highlighting new source and target vertices.
 * This handler is automatically created in mxGraph.createHandler for each selected edge.
 * **To enable adding/removing control points, the following code can be used**
 * @example
 * ```
 * mxEdgeHandler.prototype.addEnabled = true;
 * mxEdgeHandler.prototype.removeEnabled = true;
 * ```
 * Note: This experimental feature is not recommended for production use.
 * @class EdgeHandler
 */
class EdgeHandler {
  /**
   * Reference to the enclosing &lt;mxGraph>.
   */
  graph: Graph;

  /**
   * Reference to the &lt;CellState> being modified.
   */
  state: CellState;

  /**
   * Holds the &lt;mxTerminalMarker> which is used for highlighting terminals.
   */
  marker: CellMarker;

  /**
   * Holds the &lt;mxConstraintHandler> used for drawing and highlighting
   * constraints.
   */
  constraintHandler: ConstraintHandler;

  /**
   * Holds the current validation error while a connection is being changed.
   */
  error: string | null = null;

  /**
   * Holds the &lt;mxShape> that represents the preview edge.
   */
  shape: Shape;

  /**
   * Holds the &lt;mxShapes> that represent the points.
   */
  bends: Shape[] = [];

  virtualBends: Shape[] = [];

  /**
   * Holds the &lt;mxShape> that represents the label position.
   */
  labelShape: Shape;

  /**
   * Specifies if cloning by control-drag is enabled. Default is true.
   */
  cloneEnabled = true;

  /**
   * Specifies if adding bends by shift-click is enabled. Default is false.
   * Note: This experimental feature is not recommended for production use.
   */
  addEnabled = false;

  /**
   * Specifies if removing bends by shift-click is enabled. Default is false.
   * Note: This experimental feature is not recommended for production use.
   */
  removeEnabled = false;

  /**
   * Specifies if removing bends by double click is enabled. Default is false.
   */
  dblClickRemoveEnabled = false;

  /**
   * Specifies if removing bends by dropping them on other bends is enabled.
   * Default is false.
   */
  mergeRemoveEnabled = false;

  /**
   * Specifies if removing bends by creating straight segments should be enabled.
   * If enabled, this can be overridden by holding down the alt key while moving.
   * Default is false.
   */
  straightRemoveEnabled = false;

  /**
   * Specifies if virtual bends should be added in the center of each
   * segments. These bends can then be used to add new waypoints.
   * Default is false.
   */
  virtualBendsEnabled = false;

  /**
   * Opacity to be used for virtual bends (see &lt;virtualBendsEnabled>).
   * Default is 20.
   */
  virtualBendOpacity = 20;

  /**
   * Specifies if the parent should be highlighted if a child cell is selected.
   * Default is false.
   */
  parentHighlightEnabled = false;

  /**
   * Specifies if bends should be added to the graph container. This is updated
   * in &lt;init> based on whether the edge or one of its terminals has an HTML
   * label in the container.
   */
  preferHtml = false;

  /**
   * Specifies if the bounds of handles should be used for hit-detection in IE
   * Default is true.
   */
  allowHandleBoundsCheck = true;

  /**
   * Specifies if waypoints should snap to the routing centers of terminals.
   * Default is false.
   */
  snapToTerminals = false;

  /**
   * Optional &lt;mxImage> to be used as handles. Default is null.
   */
  handleImage: ImageBox | null = null;

  labelHandleImage: ImageBox | null = null;

  /**
   * Optional tolerance for hit-detection in &lt;getHandleForEvent>. Default is 0.
   */
  // tolerance: number;
  tolerance = 0;

  /**
   * Specifies if connections to the outline of a highlighted target should be
   * enabled. This will allow to place the connection point along the outline of
   * the highlighted target. Default is false.
   */
  // outlineConnect: boolean;
  outlineConnect = false;

  /**
   * Specifies if the label handle should be moved if it intersects with another
   * handle. Uses &lt;checkLabelHandle> for checking and moving. Default is false.
   */
  // manageLabelHandle: boolean;
  manageLabelHandle = false;

  escapeHandler: (sender: Listenable, evt: Event) => void;

  currentPoint: Point | null = null;

  parentHighlight: RectangleShape | null = null;

  index: number | null = null;

  isSource: boolean = false;

  isTarget: boolean = false;

  label: Point;

  isLabel = false;

  points: Point[] = [];

  snapPoint: Point | null = null;

  abspoints: (Point | null)[] = [];

  customHandles: CellHandle[] = [];

  startX = 0;
  startY = 0;

  outline = true;

  active = true;

  constructor(state: CellState) {
    // `state.shape` must exists.
    this.state = state;

    this.graph = &lt;Graph>this.state.view.graph;
    this.marker = this.createMarker();
    this.constraintHandler = new ConstraintHandler(this.graph);

    // Clones the original points from the cell
    // and makes sure at least one point exists
    this.points = [];

    // Uses the absolute points of the state
    // for the initial configuration and preview
    this.abspoints = this.getSelectionPoints(this.state);
    this.shape = this.createSelectionShape(this.abspoints);
    this.shape.dialect =
      this.graph.dialect !== DIALECT.SVG ? DIALECT.MIXEDHTML : DIALECT.SVG;
    this.shape.init(this.graph.getView().getOverlayPane());
    this.shape.pointerEvents = false;
    this.shape.setCursor(CURSOR.MOVABLE_EDGE);
    InternalEvent.redirectMouseEvents(this.shape.node, this.graph, this.state);

    // Updates preferHtml
    this.preferHtml =
      this.state.text != null &amp;&amp; this.state.text.node.parentNode === this.graph.container;

    if (!this.preferHtml) {
      // Checks source terminal
      const sourceState = this.state.getVisibleTerminalState(true);

      if (sourceState != null) {
        this.preferHtml =
          sourceState.text != null &amp;&amp;
          sourceState.text.node.parentNode === this.graph.container;
      }

      if (!this.preferHtml) {
        // Checks target terminal
        const targetState = this.state.getVisibleTerminalState(false);

        if (targetState != null) {
          this.preferHtml =
            targetState.text != null &amp;&amp;
            targetState.text.node.parentNode === this.graph.container;
        }
      }
    }

    const graphHandler = this.graph.getPlugin('SelectionHandler') as SelectionHandler;

    // Creates bends for the non-routed absolute points
    // or bends that don't correspond to points
    if (
      this.graph.getSelectionCount() &lt; graphHandler.maxCells ||
      graphHandler.maxCells &lt;= 0
    ) {
      this.bends = this.createBends();

      if (this.isVirtualBendsEnabled()) {
        this.virtualBends = this.createVirtualBends();
      }
    }

    // Adds a rectangular handle for the label position
    this.label = new Point(this.state.absoluteOffset.x, this.state.absoluteOffset.y);
    this.labelShape = this.createLabelHandleShape();
    this.initBend(this.labelShape);
    this.labelShape.setCursor(CURSOR.LABEL_HANDLE);

    this.customHandles = this.createCustomHandles();

    this.updateParentHighlight();
    this.redraw();

    // Handles escape keystrokes
    this.escapeHandler = (sender: Listenable, evt: Event) => {
      const dirty = this.index != null;
      this.reset();

      if (dirty) {
        this.graph.cellRenderer.redraw(this.state, false, state.view.isRendering());
      }
    };

    (&lt;Graph>this.state.view.graph).addListener(InternalEvent.ESCAPE, this.escapeHandler);
  }

  /**
   * Returns true if the parent highlight should be visible. This implementation
   * always returns true.
   */
  isParentHighlightVisible() {
    const parent = this.state.cell.getParent();
    return parent ? !this.graph.isCellSelected(parent) : null;
  }

  /**
   * Updates the highlight of the parent if &lt;parentHighlightEnabled> is true.
   */
  updateParentHighlight() {
    if (!this.isDestroyed()) {
      const visible = this.isParentHighlightVisible();
      const parent = this.state.cell.getParent();
      const pstate = parent ? this.graph.view.getState(parent) : null;

      if (this.parentHighlight) {
        if (parent &amp;&amp; parent.isVertex() &amp;&amp; visible) {
          const b = this.parentHighlight.bounds;

          if (
            pstate &amp;&amp;
            b &amp;&amp;
            (b.x !== pstate.x ||
              b.y !== pstate.y ||
              b.width !== pstate.width ||
              b.height !== pstate.height)
          ) {
            this.parentHighlight.bounds = Rectangle.fromRectangle(pstate);
            this.parentHighlight.redraw();
          }
        } else {
          if (pstate &amp;&amp; pstate.parentHighlight === this.parentHighlight) {
            pstate.parentHighlight = null;
          }

          this.parentHighlight.destroy();
          this.parentHighlight = null;
        }
      } else if (this.parentHighlightEnabled &amp;&amp; visible) {
        if (parent &amp;&amp; parent.isVertex() &amp;&amp; pstate &amp;&amp; !pstate.parentHighlight) {
          this.parentHighlight = this.createParentHighlightShape(pstate);
          // VML dialect required here for event transparency in IE
          this.parentHighlight.dialect = DIALECT.SVG;
          this.parentHighlight.pointerEvents = false;
          if (pstate.style.rotation) {
            this.parentHighlight.rotation = pstate.style.rotation;
          }
          this.parentHighlight.init(this.graph.getView().getOverlayPane());
          this.parentHighlight.redraw();

          // Shows highlight once per parent
          pstate.parentHighlight = this.parentHighlight;
        }
      }
    }
  }

  /**
   * Returns an array of custom handles. This implementation returns an empty array.
   */
  createCustomHandles(): CellHandle[] {
    return [];
  }

  /**
   * Returns true if virtual bends should be added. This returns true if
   * &lt;virtualBendsEnabled> is true and the current style allows and
   * renders custom waypoints.
   */
  isVirtualBendsEnabled(evt?: Event) {
    return (
      this.virtualBendsEnabled &amp;&amp;
      (this.state.style.edge == null ||
        this.state.style.edge === NONE ||
        this.state.style.noEdgeStyle) &amp;&amp;
      this.state.style.shape !== 'arrow'
    );
  }

  /**
   * Returns true if the given cell allows new connections to be created. This implementation
   * always returns true.
   */
  isCellEnabled(cell: Cell) {
    return true;
  }

  /**
   * Returns true if the given event is a trigger to add a new Point. This
   * implementation returns true if shift is pressed.
   */
  isAddPointEvent(evt: MouseEvent) {
    return isShiftDown(evt);
  }

  /**
   * Returns true if the given event is a trigger to remove a point. This
   * implementation returns true if shift is pressed.
   */
  isRemovePointEvent(evt: MouseEvent) {
    return isShiftDown(evt);
  }

  /**
   * Returns the list of points that defines the selection stroke.
   */
  getSelectionPoints(state: CellState) {
    return state.absolutePoints;
  }

  /**
   * Creates the shape used to draw the selection border.
   */
  createParentHighlightShape(bounds: Rectangle) {
    const shape = new RectangleShape(
      Rectangle.fromRectangle(bounds),
      NONE,
      this.getSelectionColor()
    );
    shape.strokeWidth = this.getSelectionStrokeWidth();
    shape.isDashed = this.isSelectionDashed();

    return shape;
  }

  /**
   * Creates the shape used to draw the selection border.
   */
  createSelectionShape(points: (Point | null)[]) {
    const c = this.state.shape!.constructor as new () => Shape;

    const shape = new c();
    shape.outline = true;
    shape.apply(this.state);

    shape.isDashed = this.isSelectionDashed();
    shape.stroke = this.getSelectionColor();
    shape.isShadow = false;

    return shape;
  }

  /**
   * Returns &lt;mxConstants.EDGE_SELECTION_COLOR>.
   */
  getSelectionColor() {
    return EDGE_SELECTION_COLOR;
  }

  /**
   * Returns &lt;mxConstants.EDGE_SELECTION_STROKEWIDTH>.
   */
  getSelectionStrokeWidth() {
    return EDGE_SELECTION_STROKEWIDTH;
  }

  /**
   * Returns &lt;mxConstants.EDGE_SELECTION_DASHED>.
   */
  isSelectionDashed() {
    return EDGE_SELECTION_DASHED;
  }

  /**
   * Returns true if the given cell is connectable. This is a hook to
   * disable floating connections. This implementation returns true.
   */
  isConnectableCell(cell: Cell) {
    return true;
  }

  /**
   * Creates and returns the &lt;mxCellMarker> used in &lt;marker>.
   */
  getCellAt(x: number, y: number) {
    return !this.outlineConnect ? this.graph.getCellAt(x, y) : null;
  }

  /**
   * Creates and returns the &lt;mxCellMarker> used in &lt;marker>.
   */
  createMarker() {
    const self = this; // closure

    class MyMarker extends CellMarker {
      // Only returns edges if they are connectable and never returns
      // the edge that is currently being modified
      getCell = (me: InternalMouseEvent) => {
        let cell = super.getCell(me);

        // Checks for cell at preview point (with grid)
        if ((cell === self.state.cell || !cell) &amp;&amp; self.currentPoint) {
          cell = self.graph.getCellAt(self.currentPoint.x, self.currentPoint.y);
        }

        // Uses connectable parent vertex if one exists
        if (cell &amp;&amp; !cell.isConnectable()) {
          const parent = cell.getParent();

          if (parent &amp;&amp; parent.isVertex() &amp;&amp; parent.isConnectable()) {
            cell = parent;
          }
        }

        if (cell) {
          if (
            (this.graph.isSwimlane(cell) &amp;&amp;
              self.currentPoint &amp;&amp;
              this.graph.hitsSwimlaneContent(
                cell,
                self.currentPoint.x,
                self.currentPoint.y
              )) ||
            !self.isConnectableCell(cell) ||
            cell === self.state.cell ||
            (cell &amp;&amp; !self.graph.connectableEdges &amp;&amp; cell.isEdge()) ||
            self.state.cell.isAncestor(cell)
          ) {
            cell = null;
          }
        }

        if (cell &amp;&amp; !cell.isConnectable()) {
          cell = null;
        }

        return cell;
      };

      // Sets the highlight color according to validateConnection
      isValidState = (state: CellState) => {
        const cell = self.state.cell.getTerminal(!self.isSource) as Cell;
        const cellState = self.graph.view.getState(cell) as CellState;
        const other = self.graph.view.getTerminalPort(state, cellState, !self.isSource);
        const otherCell = other ? other.cell : null;
        const source = self.isSource ? state.cell : otherCell;
        const target = self.isSource ? otherCell : state.cell;

        // Updates the error message of the handler
        self.error = self.validateConnection(source, target);

        return !self.error;
      };
    }

    return new MyMarker(this.graph) as CellMarker;
  }

  /**
   * Returns the error message or an empty string if the connection for the
   * given source, target pair is not valid. Otherwise it returns null. This
   * implementation uses &lt;mxGraph.getEdgeValidationError>.
   *
   * @param source &lt;Cell> that represents the source terminal.
   * @param target &lt;Cell> that represents the target terminal.
   */
  validateConnection(source: Cell | null, target: Cell | null) {
    return this.graph.getEdgeValidationError(this.state.cell, source, target);
  }

  /**
   * Creates and returns the bends used for modifying the edge. This is
   * typically an array of &lt;mxRectangleShapes>.
   */
  createBends() {
    const { cell } = this.state;
    const bends = [];

    for (let i = 0; i &lt; this.abspoints.length; i += 1) {
      if (this.isHandleVisible(i)) {
        const source = i === 0;
        const target = i === this.abspoints.length - 1;
        const terminal = source || target;

        if (terminal || this.graph.isCellBendable(cell)) {
          ((index) => {
            const bend = this.createHandleShape(index);
            this.initBend(bend, () => {
              if (this.dblClickRemoveEnabled) {
                this.removePoint(this.state, index);
              }
            });

            if (this.isHandleEnabled(i)) {
              bend.setCursor(terminal ? CURSOR.TERMINAL_HANDLE : CURSOR.BEND_HANDLE);
            }

            bends.push(bend);

            if (!terminal) {
              this.points.push(new Point(0, 0));
              bend.node.style.visibility = 'hidden';
            }
          })(i);
        }
      }
    }

    return bends;
  }

  /**
   * Creates and returns the bends used for modifying the edge. This is
   * typically an array of &lt;mxRectangleShapes>.
   */
  // createVirtualBends(): mxRectangleShape[];
  createVirtualBends() {
    const { cell } = this.state;
    const last = this.abspoints[0];
    const bends = [];

    if (this.graph.isCellBendable(cell)) {
      for (let i = 1; i &lt; this.abspoints.length; i += 1) {
        ((bend) => {
          this.initBend(bend);
          bend.setCursor(CURSOR.VIRTUAL_BEND_HANDLE);
          bends.push(bend);
        })(this.createHandleShape());
      }
    }

    return bends;
  }

  /**
   * Creates the shape used to display the given bend.
   */
  isHandleEnabled(index: number) {
    return true;
  }

  /**
   * Returns true if the handle at the given index is visible.
   */
  isHandleVisible(index: number) {
    const source = this.state.getVisibleTerminalState(true);
    const target = this.state.getVisibleTerminalState(false);
    const geo = this.state.cell.getGeometry();
    const edgeStyle = geo
      ? this.graph.view.getEdgeStyle(this.state, geo.points || undefined, source, target)
      : null;

    return (
      edgeStyle !== EdgeStyle.EntityRelation ||
      index === 0 ||
      index === this.abspoints.length - 1
    );
  }

  /**
   * Creates the shape used to display the given bend. Note that the index may be
   * null for special cases, such as when called from
   * &lt;mxElbowEdgeHandler.createVirtualBend>. Only images and rectangles should be
   * returned if support for HTML labels with not foreign objects is required.
   * Index if null for virtual handles.
   */
  createHandleShape(index?: number) {
    if (this.handleImage) {
      const shape = new ImageShape(
        new Rectangle(0, 0, this.handleImage.width, this.handleImage.height),
        this.handleImage.src
      );

      // Allows HTML rendering of the images
      shape.preserveImageAspect = false;

      return shape;
    }
    let s = HANDLE_SIZE;

    if (this.preferHtml) {
      s -= 1;
    }

    return new RectangleShape(
      new Rectangle(0, 0, s, s),
      HANDLE_FILLCOLOR,
      HANDLE_STROKECOLOR
    );
  }

  /**
   * Creates the shape used to display the the label handle.
   */
  createLabelHandleShape() {
    if (this.labelHandleImage) {
      const shape = new ImageShape(
        new Rectangle(0, 0, this.labelHandleImage.width, this.labelHandleImage.height),
        this.labelHandleImage.src
      );

      // Allows HTML rendering of the images
      shape.preserveImageAspect = false;

      return shape;
    }
    const s = LABEL_HANDLE_SIZE;
    return new RectangleShape(
      new Rectangle(0, 0, s, s),
      LABEL_HANDLE_FILLCOLOR,
      HANDLE_STROKECOLOR
    );
  }

  /**
   * Helper method to initialize the given bend.
   *
   * @param bend &lt;mxShape> that represents the bend to be initialized.
   */
  initBend(bend: Shape, dblClick?: (evt: MouseEvent) => void) {
    if (this.preferHtml) {
      bend.dialect = DIALECT.STRICTHTML;
      bend.init(this.graph.container);
    } else {
      bend.dialect = this.graph.dialect !== DIALECT.SVG ? DIALECT.MIXEDHTML : DIALECT.SVG;
      bend.init(this.graph.getView().getOverlayPane());
    }

    InternalEvent.redirectMouseEvents(
      bend.node,
      this.graph,
      this.state,
      null,
      null,
      null,
      dblClick
    );

    if (Client.IS_TOUCH) {
      bend.node.setAttribute('pointer-events', 'none');
    }
  }

  /**
   * Returns the index of the handle for the given event.
   */
  getHandleForEvent(me: InternalMouseEvent) {
    let result = null;

    // Connection highlight may consume events before they reach sizer handle
    const tol = !isMouseEvent(me.getEvent()) ? this.tolerance : 1;
    const hit =
      this.allowHandleBoundsCheck &amp;&amp; tol > 0
        ? new Rectangle(me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol)
        : null;
    let minDistSq = Number.POSITIVE_INFINITY;

    function checkShape(shape: Shape | null) {
      if (
        shape &amp;&amp;
        shape.bounds &amp;&amp;
        shape.node &amp;&amp;
        shape.node.style.display !== 'none' &amp;&amp;
        shape.node.style.visibility !== 'hidden' &amp;&amp;
        (me.isSource(shape) || (hit &amp;&amp; intersects(shape.bounds, hit)))
      ) {
        const dx = me.getGraphX() - shape.bounds.getCenterX();
        const dy = me.getGraphY() - shape.bounds.getCenterY();
        const tmp = dx * dx + dy * dy;

        if (tmp &lt;= minDistSq) {
          minDistSq = tmp;

          return true;
        }
      }

      return false;
    }

    if (this.isCustomHandleEvent(me)) {
      // Inverse loop order to match display order
      for (let i = this.customHandles.length - 1; i >= 0; i--) {
        if (checkShape(this.customHandles[i].shape)) {
          // LATER: Return reference to active shape
          return InternalEvent.CUSTOM_HANDLE - i;
        }
      }
    }

    if (me.isSource(this.state.text) || checkShape(this.labelShape)) {
      result = InternalEvent.LABEL_HANDLE;
    }

    for (let i = 0; i &lt; this.bends.length; i += 1) {
      if (checkShape(this.bends[i])) {
        result = i;
      }
    }

    if (this.isAddVirtualBendEvent(me)) {
      for (let i = 0; i &lt; this.virtualBends.length; i += 1) {
        if (checkShape(this.virtualBends[i])) {
          result = InternalEvent.VIRTUAL_HANDLE - i;
        }
      }
    }

    return result;
  }

  /**
   * Returns true if the given event allows virtual bends to be added. This
   * implementation returns true.
   */

  isAddVirtualBendEvent(me: InternalMouseEvent) {
    return true;
  }

  /**
   * Returns true if the given event allows custom handles to be changed. This
   * implementation returns true.
   */
  isCustomHandleEvent(me: InternalMouseEvent) {
    return true;
  }

  /**
   * Handles the event by checking if a special element of the handler
   * was clicked, in which case the index parameter is non-null. The
   * indices may be one of &lt;LABEL_HANDLE> or the number of the respective
   * control point. The source and target points are used for reconnecting
   * the edge.
   */
  mouseDown(sender: EventSource, me: InternalMouseEvent) {
    const handle = this.getHandleForEvent(me);

    if (handle !== null &amp;&amp; this.bends[handle]) {
      const b = this.bends[handle].bounds;
      if (b) this.snapPoint = new Point(b.getCenterX(), b.getCenterY());
    }

    if (this.addEnabled &amp;&amp; handle === null &amp;&amp; this.isAddPointEvent(me.getEvent())) {
      this.addPoint(this.state, me.getEvent());
      me.consume();
    } else if (handle !== null &amp;&amp; !me.isConsumed() &amp;&amp; this.graph.isEnabled()) {
      const cell = me.getCell();

      if (this.removeEnabled &amp;&amp; this.isRemovePointEvent(me.getEvent())) {
        this.removePoint(this.state, handle);
      } else if (
        handle !== InternalEvent.LABEL_HANDLE ||
        (cell &amp;&amp; this.graph.isLabelMovable(cell))
      ) {
        if (handle &lt;= InternalEvent.VIRTUAL_HANDLE) {
          setOpacity(this.virtualBends[InternalEvent.VIRTUAL_HANDLE - handle].node, 100);
        }
        this.start(me.getX(), me.getY(), handle);
      }
      me.consume();
    }
  }

  /**
   * Starts the handling of the mouse gesture.
   */
  start(x: number, y: number, index: number) {
    this.startX = x;
    this.startY = y;

    this.isSource = this.bends.length === 0 ? false : index === 0;
    this.isTarget = this.bends.length === 0 ? false : index === this.bends.length - 1;
    this.isLabel = index === InternalEvent.LABEL_HANDLE;

    if (this.isSource || this.isTarget) {
      const { cell } = this.state;
      const terminal = cell.getTerminal(this.isSource);

      if (
        (terminal == null &amp;&amp; this.graph.isTerminalPointMovable(cell, this.isSource)) ||
        (terminal != null &amp;&amp;
          this.graph.isCellDisconnectable(cell, terminal, this.isSource))
      ) {
        this.index = index;
      }
    } else {
      this.index = index;
    }

    // Hides other custom handles
    if (
      this.index !== null &amp;&amp;
      this.index &lt;= InternalEvent.CUSTOM_HANDLE &amp;&amp;
      this.index > InternalEvent.VIRTUAL_HANDLE
    ) {
      if (this.customHandles != null) {
        for (let i = 0; i &lt; this.customHandles.length; i += 1) {
          if (i !== InternalEvent.CUSTOM_HANDLE - this.index) {
            this.customHandles[i].setVisible(false);
          }
        }
      }
    }
  }

  /**
   * Returns a clone of the current preview state for the given point and terminal.
   */
  clonePreviewState(point: Point, terminal: Cell | null) {
    return this.state.clone();
  }

  /**
   * Returns the tolerance for the guides. Default value is
   * gridSize * scale / 2.
   */
  getSnapToTerminalTolerance() {
    return (this.graph.getGridSize() * this.graph.getView().scale) / 2;
  }

  /**
   * Hook for subclassers do show details while the handler is active.
   */

  updateHint(me: InternalMouseEvent, point: Point) {}

  /**
   * Hooks for subclassers to hide details when the handler gets inactive.
   */
  removeHint() {}

  /**
   * Hook for rounding the unscaled width or height. This uses Math.round.
   */
  roundLength(length: number) {
    return Math.round(length);
  }

  /**
   * Returns true if &lt;snapToTerminals> is true and if alt is not pressed.
   */
  isSnapToTerminalsEvent(me: InternalMouseEvent) {
    return this.snapToTerminals &amp;&amp; !isAltDown(me.getEvent());
  }

  /**
   * Returns the point for the given event.
   */
  // getPointForEvent(me: mxMouseEvent): mxPoint;
  getPointForEvent(me: InternalMouseEvent) {
    const view = this.graph.getView();
    const { scale } = view;
    const point = new Point(
      this.roundLength(me.getGraphX() / scale) * scale,
      this.roundLength(me.getGraphY() / scale) * scale
    );

    const tt = this.getSnapToTerminalTolerance();
    let overrideX = false;
    let overrideY = false;

    if (tt > 0 &amp;&amp; this.isSnapToTerminalsEvent(me)) {
      const snapToPoint = (pt: Point | null) => {
        if (pt) {
          const { x } = pt;
          if (Math.abs(point.x - x) &lt; tt) {
            point.x = x;
            overrideX = true;
          }

          const { y } = pt;
          if (Math.abs(point.y - y) &lt; tt) {
            point.y = y;
            overrideY = true;
          }
        }
      };

      // Temporary function
      const snapToTerminal = (terminal: CellState | null) => {
        if (terminal) {
          snapToPoint(
            new Point(view.getRoutingCenterX(terminal), view.getRoutingCenterY(terminal))
          );
        }
      };

      snapToTerminal(this.state.getVisibleTerminalState(true));
      snapToTerminal(this.state.getVisibleTerminalState(false));

      for (let i = 0; i &lt; this.state.absolutePoints.length; i += 1) {
        snapToPoint(this.state.absolutePoints[i]);
      }
    }

    if (this.graph.isGridEnabledEvent(me.getEvent())) {
      const tr = view.translate;

      if (!overrideX) {
        point.x = (this.graph.snap(point.x / scale - tr.x) + tr.x) * scale;
      }
      if (!overrideY) {
        point.y = (this.graph.snap(point.y / scale - tr.y) + tr.y) * scale;
      }
    }
    return point;
  }

  /**
   * Updates the given preview state taking into account the state of the constraint handler.
   */
  getPreviewTerminalState(me: InternalMouseEvent) {
    this.constraintHandler.update(
      me,
      this.isSource,
      true,
      me.isSource(this.marker.highlight.shape) ? null : this.currentPoint
    );

    if (this.constraintHandler.currentFocus &amp;&amp; this.constraintHandler.currentConstraint) {
      // Handles special case where grid is large and connection point is at actual point in which
      // case the outline is not followed as long as we're &lt; gridSize / 2 away from that point
      if (
        this.marker.highlight &amp;&amp;
        this.marker.highlight.shape &amp;&amp;
        this.marker.highlight.state &amp;&amp;
        this.marker.highlight.state.cell === this.constraintHandler.currentFocus.cell
      ) {
        // Direct repaint needed if cell already highlighted
        if (this.marker.highlight.shape.stroke !== 'transparent') {
          this.marker.highlight.shape.stroke = 'transparent';
          this.marker.highlight.repaint();
        }
      } else {
        this.marker.markCell(this.constraintHandler.currentFocus.cell, 'transparent');
      }

      const other = this.graph.view.getTerminalPort(
        this.state,
        this.graph.view.getState(
          this.state.cell.getTerminal(!this.isSource) as Cell
        ) as CellState,
        !this.isSource
      );
      const otherCell = other ? other.cell : null;
      const source = this.isSource ? this.constraintHandler.currentFocus.cell : otherCell;
      const target = this.isSource ? otherCell : this.constraintHandler.currentFocus.cell;

      // Updates the error message of the handler
      this.error = this.validateConnection(source, target);
      let result = null;

      if (this.error === null) {
        result = this.constraintHandler.currentFocus;
      }

      if (this.error !== null || (result &amp;&amp; !this.isCellEnabled(result.cell))) {
        this.constraintHandler.reset();
      }

      return result;
    }
    if (!this.graph.isIgnoreTerminalEvent(me.getEvent())) {
      this.marker.process(me);
      const state = this.marker.getValidState();

      if (state &amp;&amp; !this.isCellEnabled(state.cell)) {
        this.constraintHandler.reset();
        this.marker.reset();
      }

      return this.marker.getValidState();
    }
    this.marker.reset();

    return null;
  }

  /**
   * Updates the given preview state taking into account the state of the constraint handler.
   *
   * @param pt &lt;mxPoint> that contains the current pointer position.
   * @param me Optional &lt;mxMouseEvent> that contains the current event.
   */
  getPreviewPoints(pt: Point, me?: InternalMouseEvent) {
    const geometry = this.state.cell.getGeometry();

    if (!geometry) return null;

    let points = (geometry.points || []).slice();
    const point = new Point(pt.x, pt.y);
    let result: Point[] | null = null;

    if (!this.isSource &amp;&amp; !this.isTarget &amp;&amp; this.index !== null) {
      this.convertPoint(point, false);

      // Adds point from virtual bend
      if (this.index &lt;= InternalEvent.VIRTUAL_HANDLE) {
        points.splice(InternalEvent.VIRTUAL_HANDLE - this.index, 0, point);
      }

      // Removes point if dragged on terminal point
      if (!this.isSource &amp;&amp; !this.isTarget) {
        for (let i = 0; i &lt; this.bends.length; i += 1) {
          if (i !== this.index) {
            const bend = this.bends[i];

            if (bend &amp;&amp; contains(bend.bounds as Rectangle, pt.x, pt.y)) {
              if (this.index &lt;= InternalEvent.VIRTUAL_HANDLE) {
                points.splice(InternalEvent.VIRTUAL_HANDLE - this.index, 1);
              } else {
                points.splice(this.index - 1, 1);
              }

              result = points;
            }
          }
        }

        // Removes point if user tries to straighten a segment
        if (!result &amp;&amp; this.straightRemoveEnabled &amp;&amp; (!me || !isAltDown(me.getEvent()))) {
          const tol = this.graph.getEventTolerance() * this.graph.getEventTolerance();
          const abs = this.state.absolutePoints.slice();
          abs[this.index] = pt;

          // Handes special case where removing waypoint affects tolerance (flickering)
          const src = this.state.getVisibleTerminalState(true);

          if (src != null) {
            const c = this.graph.getConnectionConstraint(this.state, src, true);

            // Checks if point is not fixed
            if (c == null || this.graph.getConnectionPoint(src, c) == null) {
              abs[0] = new Point(
                src.view.getRoutingCenterX(src),
                src.view.getRoutingCenterY(src)
              );
            }
          }

          const trg = this.state.getVisibleTerminalState(false);

          if (trg != null) {
            const c = this.graph.getConnectionConstraint(this.state, trg, false);

            // Checks if point is not fixed
            if (c == null || this.graph.getConnectionPoint(trg, c) == null) {
              abs[abs.length - 1] = new Point(
                trg.view.getRoutingCenterX(trg),
                trg.view.getRoutingCenterY(trg)
              );
            }
          }

          const checkRemove = (idx: number, tmp: Point) => {
            if (
              idx > 0 &amp;&amp;
              idx &lt; abs.length - 1 &amp;&amp;
              ptSegDistSq(
                abs[idx - 1]!.x,
                abs[idx - 1]!.y,
                abs[idx + 1]!.x,
                abs[idx + 1]!.y,
                tmp.x,
                tmp.y
              ) &lt; tol
            ) {
              points.splice(idx - 1, 1);
              result = points;
            }
          };

          // LATER: Check if other points can be removed if a segment is made straight
          checkRemove(this.index, pt);
        }
      }

      // Updates existing point
      if (result == null &amp;&amp; this.index > InternalEvent.VIRTUAL_HANDLE) {
        points[this.index - 1] = point;
      }
    } else if (this.graph.isResetEdgesOnConnect()) {
      points = [];
    }

    return result != null ? result : points;
  }

  /**
   * Returns true if &lt;outlineConnect> is true and the source of the event is the outline shape
   * or shift is pressed.
   */
  isOutlineConnectEvent(me: InternalMouseEvent) {
    if (!this.currentPoint) return false;

    const offset = getOffset(this.graph.container);
    const evt = me.getEvent();

    const clientX = getClientX(evt);
    const clientY = getClientY(evt);

    const doc = document.documentElement;
    const left = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);
    const top = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);

    const gridX = this.currentPoint.x - this.graph.container.scrollLeft + offset.x - left;
    const gridY = this.currentPoint.y - this.graph.container.scrollTop + offset.y - top;

    return (
      this.outlineConnect &amp;&amp;
      !isShiftDown(me.getEvent()) &amp;&amp;
      (me.isSource(this.marker.highlight.shape) ||
        (isAltDown(me.getEvent()) &amp;&amp; me.getState() != null) ||
        this.marker.highlight.isHighlightAt(clientX, clientY) ||
        ((gridX !== clientX || gridY !== clientY) &amp;&amp;
          me.getState() == null &amp;&amp;
          this.marker.highlight.isHighlightAt(gridX, gridY)))
    );
  }

  /**
   * Updates the given preview state taking into account the state of the constraint handler.
   */
  updatePreviewState(
    edgeState: CellState,
    point: Point,
    terminalState: CellState | null,
    me: InternalMouseEvent,
    outline = false
  ) {
    // Computes the points for the edge style and terminals
    const sourceState = this.isSource
      ? terminalState
      : this.state.getVisibleTerminalState(true);
    const targetState = this.isTarget
      ? terminalState
      : this.state.getVisibleTerminalState(false);

    let sourceConstraint = this.graph.getConnectionConstraint(
      edgeState,
      sourceState,
      true
    );
    let targetConstraint = this.graph.getConnectionConstraint(
      edgeState,
      targetState,
      false
    );

    let constraint = this.constraintHandler.currentConstraint;

    if (constraint == null &amp;&amp; outline) {
      if (terminalState != null) {
        // Handles special case where mouse is on outline away from actual end point
        // in which case the grid is ignored and mouse point is used instead
        if (me.isSource(this.marker.highlight.shape)) {
          point = new Point(me.getGraphX(), me.getGraphY());
        }

        constraint = this.graph.getOutlineConstraint(point, terminalState, me);
        this.constraintHandler.setFocus(me, terminalState, this.isSource);
        this.constraintHandler.currentConstraint = constraint;
        this.constraintHandler.currentPoint = point;
      } else {
        constraint = new ConnectionConstraint(null);
      }
    }

    if (
      this.outlineConnect &amp;&amp;
      this.marker.highlight != null &amp;&amp;
      this.marker.highlight.shape != null
    ) {
      const s = this.graph.view.scale;

      if (
        this.constraintHandler.currentConstraint != null &amp;&amp;
        this.constraintHandler.currentFocus != null
      ) {
        this.marker.highlight.shape.stroke = outline
          ? OUTLINE_HIGHLIGHT_COLOR
          : 'transparent';
        this.marker.highlight.shape.strokeWidth = OUTLINE_HIGHLIGHT_STROKEWIDTH / s / s;
        this.marker.highlight.repaint();
      } else if (this.marker.hasValidState()) {
        const cell = me.getCell();

        this.marker.highlight.shape.stroke =
          cell &amp;&amp; cell.isConnectable() &amp;&amp; this.marker.getValidState() !== me.getState()
            ? 'transparent'
            : DEFAULT_VALID_COLOR;
        this.marker.highlight.shape.strokeWidth = HIGHLIGHT_STROKEWIDTH / s / s;
        this.marker.highlight.repaint();
      }
    }

    if (this.isSource) {
      sourceConstraint = constraint!;
    } else if (this.isTarget) {
      targetConstraint = constraint!;
    }

    if (this.isSource || this.isTarget) {
      if (constraint != null &amp;&amp; constraint.point != null) {
        edgeState.style[this.isSource ? 'exitX' : 'entryX'] = constraint.point.x;
        edgeState.style[this.isSource ? 'exitY' : 'entryY'] = constraint.point.y;
      } else {
        delete edgeState.style[this.isSource ? 'exitX' : 'entryX'];
        delete edgeState.style[this.isSource ? 'exitY' : 'entryY'];
      }
    }

    edgeState.setVisibleTerminalState(sourceState, true);
    edgeState.setVisibleTerminalState(targetState, false);

    if (!this.isSource || sourceState != null) {
      edgeState.view.updateFixedTerminalPoint(
        edgeState,
        sourceState,
        true,
        sourceConstraint
      );
    }

    if (!this.isTarget || targetState != null) {
      edgeState.view.updateFixedTerminalPoint(
        edgeState,
        targetState,
        false,
        targetConstraint
      );
    }

    if ((this.isSource || this.isTarget) &amp;&amp; terminalState == null) {
      edgeState.setAbsoluteTerminalPoint(point, this.isSource);

      if (this.marker.getMarkedState() == null) {
        this.error = this.graph.isAllowDanglingEdges() ? null : '';
      }
    }

    edgeState.view.updatePoints(edgeState, this.points, sourceState, targetState);
    edgeState.view.updateFloatingTerminalPoints(edgeState, sourceState, targetState);
  }

  /**
   * Handles the event by updating the preview.
   */
  mouseMove(sender: EventSource, me: InternalMouseEvent) {
    if (this.index != null &amp;&amp; this.marker != null) {
      this.currentPoint = this.getPointForEvent(me);
      this.error = null;

      // Uses the current point from the constraint handler if available
      if (
        !this.graph.isIgnoreTerminalEvent(me.getEvent()) &amp;&amp;
        isShiftDown(me.getEvent()) &amp;&amp;
        this.snapPoint != null
      ) {
        if (
          Math.abs(this.snapPoint.x - this.currentPoint.x) &lt;
          Math.abs(this.snapPoint.y - this.currentPoint.y)
        ) {
          this.currentPoint.x = this.snapPoint.x;
        } else {
          this.currentPoint.y = this.snapPoint.y;
        }
      }

      if (
        this.index &lt;= InternalEvent.CUSTOM_HANDLE &amp;&amp;
        this.index > InternalEvent.VIRTUAL_HANDLE
      ) {
        if (this.customHandles != null) {
          this.customHandles[InternalEvent.CUSTOM_HANDLE - this.index].processEvent(me);
          this.customHandles[InternalEvent.CUSTOM_HANDLE - this.index].positionChanged();

          if (this.shape != null &amp;&amp; this.shape.node != null) {
            this.shape.node.style.display = 'none';
          }
        }
      } else if (this.isLabel &amp;&amp; this.label) {
        this.label.x = this.currentPoint.x;
        this.label.y = this.currentPoint.y;
      } else {
        this.points = this.getPreviewPoints(this.currentPoint, me) as Point[];
        let terminalState =
          this.isSource || this.isTarget ? this.getPreviewTerminalState(me) : null;

        if (
          this.constraintHandler.currentConstraint != null &amp;&amp;
          this.constraintHandler.currentFocus != null &amp;&amp;
          this.constraintHandler.currentPoint != null
        ) {
          this.currentPoint = this.constraintHandler.currentPoint.clone();
        } else if (this.outlineConnect) {
          // Need to check outline before cloning terminal state
          const outline =
            this.isSource || this.isTarget ? this.isOutlineConnectEvent(me) : false;

          if (outline) {
            terminalState = this.marker.highlight.state;
          } else if (
            terminalState != null &amp;&amp;
            terminalState !== me.getState() &amp;&amp;
            me.getCell()?.isConnectable() &amp;&amp;
            this.marker.highlight.shape != null
          ) {
            this.marker.highlight.shape.stroke = 'transparent';
            this.marker.highlight.repaint();
            terminalState = null;
          }
        }

        if (terminalState != null &amp;&amp; !this.isCellEnabled(terminalState.cell)) {
          terminalState = null;
          this.marker.reset();
        }

        if (this.currentPoint) {
          const clone = this.clonePreviewState(
            this.currentPoint,
            terminalState != null ? terminalState.cell : null
          );
          this.updatePreviewState(
            clone,
            this.currentPoint,
            terminalState,
            me,
            this.outline
          );

          // Sets the color of the preview to valid or invalid, updates the
          // points of the preview and redraws
          const color =
            this.error == null ? this.marker.validColor : this.marker.invalidColor;
          this.setPreviewColor(color);
          this.abspoints = clone.absolutePoints;
          this.active = true;
          this.updateHint(me, this.currentPoint);
        }
      }

      // This should go before calling isOutlineConnectEvent above. As a workaround
      // we add an offset of gridSize to the hint to avoid problem with hit detection
      // in highlight.isHighlightAt (which uses comonentFromPoint)
      this.drawPreview();
      InternalEvent.consume(me.getEvent());
      me.consume();
    }
  }

  /**
   * Handles the event to applying the previewed changes on the edge by
   * using &lt;moveLabel>, &lt;connect> or &lt;changePoints>.
   */
  mouseUp(sender: EventSource, me: InternalMouseEvent) {
    // Workaround for wrong event source in Webkit
    if (this.index != null &amp;&amp; this.marker != null) {
      if (this.shape != null &amp;&amp; this.shape.node != null) {
        this.shape.node.style.display = '';
      }

      let edge = this.state.cell;
      const { index } = this;
      this.index = null;

      // Ignores event if mouse has not been moved
      if (me.getX() !== this.startX || me.getY() !== this.startY) {
        let clone =
          !this.graph.isIgnoreTerminalEvent(me.getEvent()) &amp;&amp;
          this.graph.isCloneEvent(me.getEvent()) &amp;&amp;
          this.cloneEnabled &amp;&amp;
          this.graph.isCellsCloneable();

        // Displays the reason for not carriying out the change
        // if there is an error message with non-zero length
        if (this.error != null) {
          if (this.error.length > 0) {
            this.graph.validationAlert(this.error);
          }
        } else if (
          index &lt;= InternalEvent.CUSTOM_HANDLE &amp;&amp;
          index > InternalEvent.VIRTUAL_HANDLE
        ) {
          if (this.customHandles != null) {
            const model = this.graph.getModel();

            model.beginUpdate();
            try {
              this.customHandles[InternalEvent.CUSTOM_HANDLE - index].execute(me);

              if (this.shape != null &amp;&amp; this.shape.node != null) {
                this.shape.apply(this.state);
                this.shape.redraw();
              }
            } finally {
              model.endUpdate();
            }
          }
        } else if (this.isLabel &amp;&amp; this.label) {
          this.moveLabel(this.state, this.label.x, this.label.y);
        } else if (this.isSource || this.isTarget) {
          let terminal: Cell | null = null;

          if (
            this.constraintHandler.currentConstraint != null &amp;&amp;
            this.constraintHandler.currentFocus != null
          ) {
            terminal = this.constraintHandler.currentFocus.cell;
          }

          if (
            !terminal &amp;&amp;
            this.marker.hasValidState() &amp;&amp;
            this.marker.highlight != null &amp;&amp;
            this.marker.highlight.shape != null &amp;&amp;
            this.marker.highlight.shape.stroke !== 'transparent' &amp;&amp;
            this.marker.highlight.shape.stroke !== 'white'
          ) {
            terminal = this.marker.validState!.cell;
          }

          if (terminal) {
            const model = this.graph.getModel();
            const parent = edge.getParent();

            model.beginUpdate();
            try {
              // Clones and adds the cell
              if (clone) {
                let geo = edge.getGeometry();
                const cloned = this.graph.cloneCell(edge);
                model.add(parent, cloned, parent!.getChildCount());

                if (geo != null) {
                  geo = geo.clone();
                  model.setGeometry(cloned, geo);
                }

                const other = edge.getTerminal(!this.isSource) as Cell;
                this.graph.connectCell(cloned, other, !this.isSource);

                edge = cloned;
              }

              edge = this.connect(edge, terminal, this.isSource, clone, me);
            } finally {
              model.endUpdate();
            }
          } else if (this.graph.isAllowDanglingEdges()) {
            const pt = this.abspoints[
              this.isSource ? 0 : this.abspoints.length - 1
            ] as Point;
            pt.x = this.roundLength(
              pt.x / this.graph.view.scale - this.graph.view.translate.x
            );
            pt.y = this.roundLength(
              pt.y / this.graph.view.scale - this.graph.view.translate.y
            );

            const parent = edge.getParent();
            const pstate = parent ? this.graph.getView().getState(parent) : null;

            if (pstate != null) {
              pt.x -= pstate.origin.x;
              pt.y -= pstate.origin.y;
            }

            pt.x -= this.graph.getPanDx() / this.graph.view.scale;
            pt.y -= this.graph.getPanDy() / this.graph.view.scale;

            // Destroys and recreates this handler
            edge = this.changeTerminalPoint(edge, pt, this.isSource, clone);
          }
        } else if (this.active) {
          edge = this.changePoints(edge, this.points, clone);
        } else {
          this.graph.getView().invalidate(this.state.cell);
          this.graph.getView().validate(this.state.cell);
        }
      } else if (this.graph.isToggleEvent(me.getEvent())) {
        this.graph.selectCellForEvent(this.state.cell, me.getEvent());
      }

      // Resets the preview color the state of the handler if this
      // handler has not been recreated
      if (this.marker != null) {
        this.reset();

        // Updates the selection if the edge has been cloned
        if (edge !== this.state.cell) {
          this.graph.setSelectionCell(edge);
        }
      }

      me.consume();
    }
  }

  /**
   * Resets the state of this handler.
   */
  reset() {
    if (this.active) {
      this.refresh();
    }

    this.error = null;
    this.index = null;
    this.points = [];
    this.snapPoint = null;
    this.isLabel = false;
    this.isSource = false;
    this.isTarget = false;
    this.active = false;

    if (this.marker) {
      this.marker.reset();
    }

    this.constraintHandler.reset();

    for (let i = 0; i &lt; this.customHandles.length; i += 1) {
      this.customHandles[i].reset();
    }

    this.setPreviewColor(EDGE_SELECTION_COLOR);
    this.removeHint();
    this.redraw();
  }

  /**
   * Sets the color of the preview to the given value.
   */
  setPreviewColor(color: ColorValue) {
    this.shape.stroke = color;
  }

  /**
   * Converts the given point in-place from screen to unscaled, untranslated
   * graph coordinates and applies the grid. Returns the given, modified
   * point instance.
   *
   * @param point &lt;mxPoint> to be converted.
   * @param gridEnabled Boolean that specifies if the grid should be applied.
   */
  convertPoint(point: Point, gridEnabled: boolean) {
    const scale = this.graph.getView().getScale();
    const tr = this.graph.getView().getTranslate();

    if (gridEnabled) {
      point.x = this.graph.snap(point.x);
      point.y = this.graph.snap(point.y);
    }

    point.x = Math.round(point.x / scale - tr.x);
    point.y = Math.round(point.y / scale - tr.y);

    const parent = this.state.cell.getParent();
    const pstate = parent ? this.graph.getView().getState(parent) : parent;

    if (pstate) {
      point.x -= pstate.origin.x;
      point.y -= pstate.origin.y;
    }

    return point;
  }

  /**
   * Changes the coordinates for the label of the given edge.
   *
   * @param edge &lt;Cell> that represents the edge.
   * @param x Integer that specifies the x-coordinate of the new location.
   * @param y Integer that specifies the y-coordinate of the new location.
   */
  moveLabel(edgeState: CellState, x: number, y: number) {
    const model = this.graph.getModel();
    let geometry = edgeState.cell.getGeometry();

    if (geometry != null) {
      const { scale } = this.graph.getView();
      geometry = geometry.clone();

      if (geometry.relative) {
        // Resets the relative location stored inside the geometry
        let pt = this.graph.getView().getRelativePoint(edgeState, x, y);
        geometry.x = Math.round(pt.x * 10000) / 10000;
        geometry.y = Math.round(pt.y);

        // Resets the offset inside the geometry to find the offset
        // from the resulting point
        geometry.offset = new Point(0, 0);
        pt = this.graph.view.getPoint(edgeState, geometry);
        geometry.offset = new Point(
          Math.round((x - pt.x) / scale),
          Math.round((y - pt.y) / scale)
        );
      } else {
        const points = edgeState.absolutePoints;
        const p0 = points[0];
        const pe = points[points.length - 1];

        if (p0 != null &amp;&amp; pe != null) {
          const cx = p0.x + (pe.x - p0.x) / 2;
          const cy = p0.y + (pe.y - p0.y) / 2;

          geometry.offset = new Point(
            Math.round((x - cx) / scale),
            Math.round((y - cy) / scale)
          );
          geometry.x = 0;
          geometry.y = 0;
        }
      }

      model.setGeometry(edgeState.cell, geometry);
    }
  }

  /**
   * Changes the terminal or terminal point of the given edge in the graph
   * model.
   *
   * @param edge &lt;Cell> that represents the edge to be reconnected.
   * @param terminal &lt;Cell> that represents the new terminal.
   * @param isSource Boolean indicating if the new terminal is the source or
   * target terminal.
   * @param isClone Boolean indicating if the new connection should be a clone of
   * the old edge.
   * @param me &lt;mxMouseEvent> that contains the mouse up event.
   */
  connect(
    edge: Cell,
    terminal: Cell,
    isSource: boolean,
    isClone: boolean,
    me: InternalMouseEvent
  ) {
    const model = this.graph.getModel();
    const parent = edge.getParent();

    model.beginUpdate();
    try {
      let constraint = this.constraintHandler.currentConstraint;

      if (constraint == null) {
        constraint = new ConnectionConstraint(null);
      }

      this.graph.connectCell(edge, terminal, isSource, constraint);
    } finally {
      model.endUpdate();
    }

    return edge;
  }

  /**
   * Changes the terminal point of the given edge.
   */
  changeTerminalPoint(edge: Cell, point: Point, isSource: boolean, clone: boolean) {
    const model = this.graph.getModel();

    model.beginUpdate();
    try {
      if (clone) {
        const parent = edge.getParent();
        const terminal = edge.getTerminal(!isSource);
        edge = this.graph.cloneCell(edge);
        model.add(parent, edge, parent!.getChildCount());
        model.setTerminal(edge, terminal, !isSource);
      }

      let geo = edge.getGeometry();

      if (geo != null) {
        geo = geo.clone();
        geo.setTerminalPoint(point, isSource);
        model.setGeometry(edge, geo);
        this.graph.connectCell(edge, null, isSource, new ConnectionConstraint(null));
      }
    } finally {
      model.endUpdate();
    }

    return edge;
  }

  /**
   * Changes the control points of the given edge in the graph model.
   */
  changePoints(edge: Cell, points: Point[], clone: boolean) {
    const model = this.graph.getModel();
    model.beginUpdate();
    try {
      if (clone) {
        const parent = edge.getParent();
        const source = edge.getTerminal(true);
        const target = edge.getTerminal(false);
        edge = this.graph.cloneCell(edge);
        model.add(parent, edge, parent!.getChildCount());
        model.setTerminal(edge, source, true);
        model.setTerminal(edge, target, false);
      }

      let geo = edge.getGeometry();

      if (geo != null) {
        geo = geo.clone();
        geo.points = points;

        model.setGeometry(edge, geo);
      }
    } finally {
      model.endUpdate();
    }

    return edge;
  }

  /**
   * Adds a control point for the given state and event.
   */
  addPoint(state: CellState, evt: MouseEvent) {
    const pt = convertPoint(this.graph.container, getClientX(evt), getClientY(evt));
    const gridEnabled = this.graph.isGridEnabledEvent(evt);
    this.convertPoint(pt, gridEnabled);
    this.addPointAt(state, pt.x, pt.y);
    InternalEvent.consume(evt);
  }

  /**
   * Adds a control point at the given point.
   */
  addPointAt(state: CellState, x: number, y: number) {
    let geo = state.cell.getGeometry();
    const pt = new Point(x, y);

    if (geo != null) {
      geo = geo.clone();
      const t = this.graph.view.translate;
      const s = this.graph.view.scale;
      let offset = new Point(t.x * s, t.y * s);

      const parent = this.state.cell.getParent();

      if (parent &amp;&amp; parent.isVertex()) {
        const pState = this.graph.view.getState(parent);

        if (pState) offset = new Point(pState.x, pState.y);
      }

      const index = findNearestSegment(state, pt.x * s + offset.x, pt.y * s + offset.y);

      if (geo.points == null) {
        geo.points = [pt];
      } else {
        geo.points.splice(index, 0, pt);
      }

      this.graph.getModel().setGeometry(state.cell, geo);
      this.refresh();
      this.redraw();
    }
  }

  /**
   * Removes the control point at the given index from the given state.
   */
  removePoint(state: CellState, index: number) {
    if (index > 0 &amp;&amp; index &lt; this.abspoints.length - 1) {
      let geo = this.state.cell.getGeometry();

      if (geo != null &amp;&amp; geo.points != null) {
        geo = geo.clone();
        (geo.points || []).splice(index - 1, 1);
        this.graph.getModel().setGeometry(state.cell, geo);
        this.refresh();
        this.redraw();
      }
    }
  }

  /**
   * Returns the fillcolor for the handle at the given index.
   */
  getHandleFillColor(index: number) {
    const isSource = index === 0;
    const { cell } = this.state;
    const terminal = cell.getTerminal(isSource);
    let color = HANDLE_FILLCOLOR;

    if (
      (terminal != null &amp;&amp; !this.graph.isCellDisconnectable(cell, terminal, isSource)) ||
      (terminal == null &amp;&amp; !this.graph.isTerminalPointMovable(cell, isSource))
    ) {
      color = LOCKED_HANDLE_FILLCOLOR;
    } else if (
      terminal != null &amp;&amp;
      this.graph.isCellDisconnectable(cell, terminal, isSource)
    ) {
      color = CONNECT_HANDLE_FILLCOLOR;
    }

    return color;
  }

  /**
   * Redraws the preview, and the bends- and label control points.
   */
  redraw(ignoreHandles?: boolean) {
    this.abspoints = this.state.absolutePoints.slice();
    const g = this.state.cell.getGeometry();

    if (g) {
      const pts = g.points;

      if (this.bends != null &amp;&amp; this.bends.length > 0) {
        if (pts != null) {
          if (this.points == null) {
            this.points = [];
          }

          for (let i = 1; i &lt; this.bends.length - 1; i += 1) {
            if (this.bends[i] != null &amp;&amp; this.abspoints[i] != null) {
              this.points[i - 1] = pts[i - 1];
            }
          }
        }
      }
    }

    this.drawPreview();

    if (!ignoreHandles) {
      this.redrawHandles();
    }
  }

  /**
   * Redraws the handles.
   */
  redrawHandles() {
    const { cell } = this.state;

    // Updates the handle for the label position
    let b = this.labelShape.bounds as Rectangle;

    this.label = new Point(this.state.absoluteOffset.x, this.state.absoluteOffset.y);
    this.labelShape.bounds = new Rectangle(
      Math.round(this.label.x - b.width / 2),
      Math.round(this.label.y - b.height / 2),
      b.width,
      b.height
    );

    // Shows or hides the label handle depending on the label
    const lab = this.graph.getLabel(cell);
    this.labelShape.visible =
      lab != null &amp;&amp; lab.length > 0 &amp;&amp; this.graph.isLabelMovable(cell);

    if (this.bends != null &amp;&amp; this.bends.length > 0) {
      const n = this.abspoints.length - 1;

      const p0 = this.abspoints[0] as Point;
      const x0 = p0.x;
      const y0 = p0.y;

      b = this.bends[0].bounds as Rectangle;

      this.bends[0].bounds = new Rectangle(
        Math.floor(x0 - b.width / 2),
        Math.floor(y0 - b.height / 2),
        b.width,
        b.height
      );
      this.bends[0].fill = this.getHandleFillColor(0);
      this.bends[0].redraw();

      if (this.manageLabelHandle) {
        this.checkLabelHandle(this.bends[0].bounds);
      }

      const pe = this.abspoints[n] as Point;
      const xn = pe.x;
      const yn = pe.y;

      const bn = this.bends.length - 1;
      b = this.bends[bn].bounds as Rectangle;
      this.bends[bn].bounds = new Rectangle(
        Math.floor(xn - b.width / 2),
        Math.floor(yn - b.height / 2),
        b.width,
        b.height
      );
      this.bends[bn].fill = this.getHandleFillColor(bn);
      this.bends[bn].redraw();

      if (this.manageLabelHandle) {
        this.checkLabelHandle(this.bends[bn].bounds as Rectangle);
      }

      this.redrawInnerBends(p0, pe);
    }

    if (this.virtualBends.length > 0) {
      let last = this.abspoints[0] as Point;

      for (let i = 0; i &lt; this.virtualBends.length; i += 1) {
        if (this.virtualBends[i] != null &amp;&amp; this.abspoints[i + 1] != null) {
          const pt = this.abspoints[i + 1] as Point;
          const b = this.virtualBends[i];
          const x = last.x + (pt.x - last.x) / 2;
          const y = last.y + (pt.y - last.y) / 2;

          if (b.bounds) {
            b.bounds = new Rectangle(
              Math.floor(x - b.bounds.width / 2),
              Math.floor(y - b.bounds.height / 2),
              b.bounds.width,
              b.bounds.height
            );
            b.redraw();
          }

          setOpacity(b.node, this.virtualBendOpacity);
          last = pt;

          if (this.manageLabelHandle) {
            this.checkLabelHandle(b.bounds as Rectangle);
          }
        }
      }
    }

    this.labelShape.redraw();

    for (let i = 0; i &lt; this.customHandles.length; i += 1) {
      const shape = this.customHandles[i].shape;

      if (shape) {
        const temp = shape.node.style.display;
        this.customHandles[i].redraw();
        shape.node.style.display = temp;

        // Hides custom handles during text editing
        shape.node.style.visibility = this.isCustomHandleVisible(this.customHandles[i])
          ? ''
          : 'hidden';
      }
    }
  }

  /**
   * Returns true if the given custom handle is visible.
   */
  isCustomHandleVisible(handle: CellHandle) {
    return !this.graph.isEditing() &amp;&amp; (&lt;Graph>this.state.view.graph).getSelectionCount() === 1;
  }

  /**
   * Shortcut to &lt;hideSizers>.
   */
  setHandlesVisible(visible: boolean) {
    for (let i = 0; i &lt; this.bends.length; i += 1) {
      this.bends[i].node.style.display = visible ? '' : 'none';
    }

    for (let i = 0; i &lt; this.virtualBends.length; i += 1) {
      this.virtualBends[i].node.style.display = visible ? '' : 'none';
    }

    this.labelShape.node.style.display = visible ? '' : 'none';

    for (let i = 0; i &lt; this.customHandles.length; i += 1) {
      this.customHandles[i].setVisible(visible);
    }
  }

  /**
   * Updates and redraws the inner bends.
   *
   * @param p0 &lt;mxPoint> that represents the location of the first point.
   * @param pe &lt;mxPoint> that represents the location of the last point.
   */
  redrawInnerBends(p0: Point, pe: Point) {
    for (let i = 1; i &lt; this.bends.length - 1; i += 1) {
      if (this.bends[i] != null) {
        if (this.abspoints[i] != null) {
          const { x } = this.abspoints[i] as Point;
          const { y } = this.abspoints[i] as Point;

          const b = this.bends[i].bounds as Rectangle;
          this.bends[i].node.style.visibility = 'visible';
          this.bends[i].bounds = new Rectangle(
            Math.round(x - b.width / 2),
            Math.round(y - b.height / 2),
            b.width,
            b.height
          );

          if (this.manageLabelHandle) {
            this.checkLabelHandle(this.bends[i].bounds as Rectangle);
          } else if (
            this.handleImage == null &amp;&amp;
            this.labelShape.visible &amp;&amp;
            intersects(
              this.bends[i].bounds as Rectangle,
              this.labelShape.bounds as Rectangle
            )
          ) {
            const w = HANDLE_SIZE + 3;
            const h = HANDLE_SIZE + 3;
            this.bends[i].bounds = new Rectangle(
              Math.round(x - w / 2),
              Math.round(y - h / 2),
              w,
              h
            );
          }

          this.bends[i].redraw();
        } else {
          this.bends[i].destroy();
        }
      }
    }
  }

  /**
   * Checks if the label handle intersects the given bounds and moves it if it
   * intersects.
   */
  checkLabelHandle(b: Rectangle) {
    const b2 = this.labelShape.bounds as Rectangle;

    if (intersects(b, b2)) {
      if (b.getCenterY() &lt; b2.getCenterY()) {
        b2.y = b.y + b.height;
      } else {
        b2.y = b.y - b2.height;
      }
    }
  }

  /**
   * Redraws the preview.
   */
  drawPreview() {
    try {
      if (this.isLabel) {
        const b = this.labelShape.bounds as Rectangle;
        const bounds = new Rectangle(
          Math.round(this.label.x - b.width / 2),
          Math.round(this.label.y - b.height / 2),
          b.width,
          b.height
        );

        if (!b.equals(bounds)) {
          this.labelShape.bounds = bounds;
          this.labelShape.redraw();
        }
      }

      if (this.shape != null &amp;&amp; !equalPoints(this.shape.points, this.abspoints)) {
        this.shape.apply(this.state);
        this.shape.points = this.abspoints.slice();
        this.shape.scale = this.state.view.scale;
        this.shape.isDashed = this.isSelectionDashed();
        this.shape.stroke = this.getSelectionColor();
        this.shape.strokeWidth =
          this.getSelectionStrokeWidth() / this.shape.scale / this.shape.scale;
        this.shape.isShadow = false;
        this.shape.redraw();
      }

      this.updateParentHighlight();
    } catch (e) {
      // ignore
    }
  }

  /**
   * Refreshes the bends of this handler.
   */
  refresh() {
    if (this.state != null) {
      this.abspoints = this.getSelectionPoints(this.state);
      this.points = [];

      this.destroyBends(this.bends);
      this.bends = this.createBends();

      this.destroyBends(this.virtualBends);
      this.virtualBends = this.createVirtualBends();

      this.destroyBends(this.customHandles);
      this.customHandles = this.createCustomHandles();

      // Puts label node on top of bends
      if (
        this.labelShape != null &amp;&amp;
        this.labelShape.node != null &amp;&amp;
        this.labelShape.node.parentNode != null
      ) {
        this.labelShape.node.parentNode.appendChild(this.labelShape.node);
      }
    }
  }

  /**
   * Returns true if &lt;destroy> was called.
   */
  isDestroyed() {
    return this.shape == null;
  }

  /**
   * Destroys all elements in &lt;bends>.
   */
  destroyBends(bends: Shape[] | CellHandle[]) {
    if (bends != null) {
      for (let i = 0; i &lt; bends.length; i += 1) {
        if (bends[i] != null) {
          bends[i].destroy();
        }
      }
    }
  }

  /**
   * Destroys the handler and all its resources and DOM nodes. This does
   * normally not need to be called as handlers are destroyed automatically
   * when the corresponding cell is deselected.
   */
  onDestroy() {
    (&lt;Graph>this.state.view.graph).removeListener(this.escapeHandler);

    this.marker.destroy();
    // @ts-expect-error Can be null when destroyed.
    this.marker = null;

    this.shape.destroy();
    // @ts-expect-error Can be null when destroyed.
    this.shape = null;

    if (this.parentHighlight) {
      const parent = this.state.cell.getParent();
      const pstate = parent ? this.graph.view.getState(parent) : null;

      if (pstate &amp;&amp; pstate.parentHighlight === this.parentHighlight) {
        pstate.parentHighlight = null;
      }

      this.parentHighlight.destroy();
      this.parentHighlight = null;
    }

    this.labelShape.destroy();
    // @ts-expect-error Can be null when destroyed.
    this.labelShape = null;

    this.constraintHandler.onDestroy();
    // @ts-expect-error Can be null when destroyed.
    this.constraintHandler = null;

    this.destroyBends(this.virtualBends);
    this.virtualBends = [];

    this.destroyBends(this.customHandles);
    this.customHandles = [];

    this.destroyBends(this.bends);
    this.bends = [];

    this.removeHint();
  }
}

export default EdgeHandler;
</code></pre>
        </article>
    </section>




            </div>
            
            <footer class="footer">
                <div class="content has-text-centered">
                    <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a></p>
                    <p class="sidebar-created-by">
                        <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by 
                        <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers - JavaScript Development Agency</a>
                    </p>
                </div>
            </footer>
            
        </div>
        <div id="side-nav" class="side-nav">
        </div>
    </div>
<script src="scripts/app.min.js"></script>
<script>PR.prettyPrint();</script>
<script src="scripts/linenumber.js"> </script>

<script src="scripts/search.js"> </script>

</body>
</html>
