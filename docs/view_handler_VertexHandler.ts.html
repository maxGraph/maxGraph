

<!DOCTYPE html>
<html lang="en">

<head>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title> view/handler/VertexHandler.ts</title>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="./build/entry.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,400,700|Inconsolata,700" rel="stylesheet">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
  <link type="text/css" rel="stylesheet" href="styles/app.min.css">
  <link type="text/css" rel="stylesheet" href="styles/iframe.css">
  <link type="text/css" rel="stylesheet" href="">
  <script async defer src="https://buttons.github.io/buttons.js"></script>

  
</head>



<body class="layout small-header">
    <div id="stickyNavbarOverlay"></div>
    

<div class="top-nav">
    <div class="inner">
        <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
        <div class="logo">
            
            
        </div>
        <div class="menu">
            
            <div class="navigation">
                <a
                    href="index.html"
                    class="link"
                >
                    API Documentation
                </a>
                
                
                
            </div>
        </div>
    </div>
</div>
    <div id="main">
        <div
            class="sidebar "
            id="sidebarNav"
        >
            
            <nav>
                
                    <h2><a href="index.html">Documentation</a></h2><div class="category"><h3>Classes</h3><ul><li><a href="AbstractCanvas2D.html">AbstractCanvas2D</a></li><li><a href="ActorShape.html">ActorShape</a></li><li><a href="Animation.html">Animation</a></li><li><a href="ArrowConnectorShape.html">ArrowConnectorShape</a></li><li><a href="ArrowShape.html">ArrowShape</a></li><li><a href="AutoSaveManager.html">AutoSaveManager</a></li><li><a href="Cell.html">Cell</a></li><li><a href="CellAttributeChange.html">CellAttributeChange</a></li><li><a href="CellCodec.html">CellCodec</a></li><li><a href="CellEditorHandler.html">CellEditorHandler</a></li><li><a href="CellHighlight.html">CellHighlight</a></li><li><a href="CellMarker.html">CellMarker</a></li><li><a href="CellOverlay.html">CellOverlay</a></li><li><a href="CellPath.html">CellPath</a></li><li><a href="CellRenderer.html">CellRenderer</a></li><li><a href="CellState.html">CellState</a></li><li><a href="CellStatePreview.html">CellStatePreview</a></li><li><a href="CellTracker.html">CellTracker</a></li><li><a href="ChildChange.html">ChildChange</a></li><li><a href="ChildChangeCodec.html">ChildChangeCodec</a></li><li><a href="CircleLayout.html">CircleLayout</a></li><li><a href="Client.html">Client</a></li><li><a href="Clipboard.html">Clipboard</a></li><li><a href="CloudShape.html">CloudShape</a></li><li><a href="Codec.html">Codec</a></li><li><a href="CodecRegistry.html">CodecRegistry</a></li><li><a href="CollapseChange.html">CollapseChange</a></li><li><a href="CompactTreeLayout.html">CompactTreeLayout</a></li><li><a href="CompositeLayout.html">CompositeLayout</a></li><li><a href="ConnectionConstraint.html">ConnectionConstraint</a></li><li><a href="ConnectionHandler.html">ConnectionHandler</a></li><li><a href="ConnectorShape.html">ConnectorShape</a></li><li><a href="ConstraintHandler.html">ConstraintHandler</a></li><li><a href="CoordinateAssignment.html">CoordinateAssignment</a></li><li><a href="CurrentRootChange.html">CurrentRootChange</a></li><li><a href="CylinderShape.html">CylinderShape</a></li><li><a href="Dictionary.html">Dictionary</a></li><li><a href="DoubleEllipseShape.html">DoubleEllipseShape</a></li><li><a href="DragSource.html">DragSource</a></li><li><a href="EdgeHandler.html">EdgeHandler</a></li><li><a href="EdgeLabelLayout.html">EdgeLabelLayout</a></li><li><a href="EdgeStyle.html">EdgeStyle</a></li><li><a href="Editor.html">Editor</a></li><li><a href="EditorCodec.html">EditorCodec</a></li><li><a href="EditorKeyHandler.html">EditorKeyHandler</a></li><li><a href="EditorKeyHandlerCodec.html">EditorKeyHandlerCodec</a></li><li><a href="EditorPopupMenu.html">EditorPopupMenu</a></li><li><a href="EditorPopupMenuCodec.html">EditorPopupMenuCodec</a></li><li><a href="EditorToolbar.html">EditorToolbar</a></li><li><a href="EditorToolbarCodec.html">EditorToolbarCodec</a></li><li><a href="Effects.html">Effects</a></li><li><a href="ElbowEdgeHandler.html">ElbowEdgeHandler</a></li><li><a href="EllipseShape.html">EllipseShape</a></li><li><a href="EventObject.html">EventObject</a></li><li><a href="EventSource.html">EventSource</a></li><li><a href="GenericChangeCodec.html">GenericChangeCodec</a></li><li><a href="Geometry.html">Geometry</a></li><li><a href="GeometryChange.html">GeometryChange</a></li><li><a href="graph.html">graph</a></li><li><a href="GraphAbstractHierarchyCell.html">GraphAbstractHierarchyCell</a></li><li><a href="GraphCodec.html">GraphCodec</a></li><li><a href="GraphHierarchyEdge.html">GraphHierarchyEdge</a></li><li><a href="GraphHierarchyModel.html">GraphHierarchyModel</a></li><li><a href="GraphHierarchyNode.html">GraphHierarchyNode</a></li><li><a href="GraphLayout.html">GraphLayout</a></li><li><a href="GraphView.html">GraphView</a></li><li><a href="GraphViewCodec.html">GraphViewCodec</a></li><li><a href="Guide.html">Guide</a></li><li><a href="HexagonShape.html">HexagonShape</a></li><li><a href="HierarchicalLayout.html">HierarchicalLayout</a></li><li><a href="HierarchicalLayoutStage.html">HierarchicalLayoutStage</a></li><li><a href="ImageBox.html">ImageBox</a></li><li><a href="ImageBundle.html">ImageBundle</a></li><li><a href="ImageExport.html">ImageExport</a></li><li><a href="ImageShape.html">ImageShape</a></li><li><a href="InternalEvent.html">InternalEvent</a></li><li><a href="InternalMouseEvent.html">InternalMouseEvent</a></li><li><a href="KeyHandler.html">KeyHandler</a></li><li><a href="LabelShape.html">LabelShape</a></li><li><a href="LayoutManager.html">LayoutManager</a></li><li><a href="Line.html">Line</a></li><li><a href="MarkerShape.html">MarkerShape</a></li><li><a href="MaxForm.html">MaxForm</a></li><li><a href="MaxLog.html">MaxLog</a></li><li><a href="MaxPopupMenu.html">MaxPopupMenu</a></li><li><a href="MaxToolbar.html">MaxToolbar</a></li><li><a href="MaxWindow.html">MaxWindow</a></li><li><a href="MaxXmlRequest.html">MaxXmlRequest</a></li><li><a href="MedianCellSorter.html">MedianCellSorter</a></li><li><a href="MedianHybridCrossingReduction.html">MedianHybridCrossingReduction</a></li><li><a href="MinimumCycleRemover.html">MinimumCycleRemover</a></li><li><a href="Model.html">Model</a></li><li><a href="ModelCodec.html">ModelCodec</a></li><li><a href="Morphing.html">Morphing</a></li><li><a href="Multiplicity.html">Multiplicity</a></li><li><a href="MxFastOrganicLayout.html">MxFastOrganicLayout</a></li><li><a href="mxXmlCanvas2D.html">mxXmlCanvas2D</a></li><li><a href="ObjectCodec.html">ObjectCodec</a></li><li><a href="ObjectIdentity.html">ObjectIdentity</a></li><li><a href="Outline.html">Outline</a></li><li><a href="PanningHandler.html">PanningHandler</a></li><li><a href="PanningManager.html">PanningManager</a></li><li><a href="ParallelEdgeLayout.html">ParallelEdgeLayout</a></li><li><a href="PartitionLayout.html">PartitionLayout</a></li><li><a href="Perimeter.html">Perimeter</a></li><li><a href="Point.html">Point</a></li><li><a href="PolylineShape.html">PolylineShape</a></li><li><a href="PopupMenuHandler.html">PopupMenuHandler</a></li><li><a href="PrintPreview.html">PrintPreview</a></li><li><a href="RadialTreeLayout.html">RadialTreeLayout</a></li><li><a href="Rectangle.html">Rectangle</a></li><li><a href="RectangleShape.html">RectangleShape</a></li><li><a href="RhombusShape.html">RhombusShape</a></li><li><a href="RootChange.html">RootChange</a></li><li><a href="RootChangeCodec.html">RootChangeCodec</a></li><li><a href="RubberBandHandler.html">RubberBandHandler</a></li><li><a href="SelectionCellsHandler.html">SelectionCellsHandler</a></li><li><a href="SelectionChange.html">SelectionChange</a></li><li><a href="SelectionHandler.html">SelectionHandler</a></li><li><a href="Shape.html">Shape</a></li><li><a href="StackLayout.html">StackLayout</a></li><li><a href="StencilShape.html">StencilShape</a></li><li><a href="StencilShapeRegistry.html">StencilShapeRegistry</a></li><li><a href="StyleChange.html">StyleChange</a></li><li><a href="StyleRegistry.html">StyleRegistry</a></li><li><a href="Stylesheet.html">Stylesheet</a></li><li><a href="StylesheetCodec.html">StylesheetCodec</a></li><li><a href="SvgCanvas2D.html">SvgCanvas2D</a></li><li><a href="SwimlaneLayout.html">SwimlaneLayout</a></li><li><a href="SwimlaneManager.html">SwimlaneManager</a></li><li><a href="SwimlaneModel.html">SwimlaneModel</a></li><li><a href="SwimlaneOrdering.html">SwimlaneOrdering</a></li><li><a href="SwimlaneShape.html">SwimlaneShape</a></li><li><a href="TerminalChange.html">TerminalChange</a></li><li><a href="TerminalChangeCodec.html">TerminalChangeCodec</a></li><li><a href="TextShape.html">TextShape</a></li><li><a href="TooltipHandler.html">TooltipHandler</a></li><li><a href="Translations.html">Translations</a></li><li><a href="TriangleShape.html">TriangleShape</a></li><li><a href="UndoableEdit.html">UndoableEdit</a></li><li><a href="UndoManager.html">UndoManager</a></li><li><a href="UrlConverter.html">UrlConverter</a></li><li><a href="ValueChange.html">ValueChange</a></li><li><a href="VertexHandle.html">VertexHandle</a></li><li><a href="VertexHandler.html">VertexHandler</a></li><li><a href="VisibleChange.html">VisibleChange</a></li></ul><h3>Global</h3><ul><li><a href="global.html#ABSOLUTE_LINE_HEIGHT">ABSOLUTE_LINE_HEIGHT</a></li><li><a href="global.html#addStylename">addStylename</a></li><li><a href="global.html#ALIGN">ALIGN</a></li><li><a href="global.html#arcToCurves">arcToCurves</a></li><li><a href="global.html#ARROW">ARROW</a></li><li><a href="global.html#ARROW_SIZE">ARROW_SIZE</a></li><li><a href="global.html#ARROW_SPACING">ARROW_SPACING</a></li><li><a href="global.html#ARROW_WIDTH">ARROW_WIDTH</a></li><li><a href="global.html#br">br</a></li><li><a href="global.html#button">button</a></li><li><a href="global.html#clearSelection">clearSelection</a></li><li><a href="global.html#clone">clone</a></li><li><a href="global.html#CONNECT_HANDLE_FILLCOLOR">CONNECT_HANDLE_FILLCOLOR</a></li><li><a href="global.html#CONNECT_TARGET_COLOR">CONNECT_TARGET_COLOR</a></li><li><a href="global.html#contains">contains</a></li><li><a href="global.html#convertPoint">convertPoint</a></li><li><a href="global.html#createImage">createImage</a></li><li><a href="global.html#createXmlDocument">createXmlDocument</a></li><li><a href="global.html#CURSOR">CURSOR</a></li><li><a href="global.html#DEFAULT_FONTFAMILY">DEFAULT_FONTFAMILY</a></li><li><a href="global.html#DEFAULT_FONTSIZE">DEFAULT_FONTSIZE</a></li><li><a href="global.html#DEFAULT_FONTSTYLE">DEFAULT_FONTSTYLE</a></li><li><a href="global.html#DEFAULT_HOTSPOT">DEFAULT_HOTSPOT</a></li><li><a href="global.html#DEFAULT_IMAGESIZE">DEFAULT_IMAGESIZE</a></li><li><a href="global.html#DEFAULT_INVALID_COLOR">DEFAULT_INVALID_COLOR</a></li><li><a href="global.html#DEFAULT_MARKERSIZE">DEFAULT_MARKERSIZE</a></li><li><a href="global.html#DEFAULT_STARTSIZE">DEFAULT_STARTSIZE</a></li><li><a href="global.html#DEFAULT_TEXT_DIRECTION">DEFAULT_TEXT_DIRECTION</a></li><li><a href="global.html#DEFAULT_VALID_COLOR">DEFAULT_VALID_COLOR</a></li><li><a href="global.html#DIALECT">DIALECT</a></li><li><a href="global.html#DIRECTION_MASK">DIRECTION_MASK</a></li><li><a href="global.html#DROP_TARGET_COLOR">DROP_TARGET_COLOR</a></li><li><a href="global.html#EDGE_SELECTION_COLOR">EDGE_SELECTION_COLOR</a></li><li><a href="global.html#EDGE_SELECTION_DASHED">EDGE_SELECTION_DASHED</a></li><li><a href="global.html#EDGE_SELECTION_STROKEWIDTH">EDGE_SELECTION_STROKEWIDTH</a></li><li><a href="global.html#EDGESTYLE">EDGESTYLE</a></li><li><a href="global.html#ELBOW">ELBOW</a></li><li><a href="global.html#ENTITY_SEGMENT">ENTITY_SEGMENT</a></li><li><a href="global.html#equalEntries">equalEntries</a></li><li><a href="global.html#equalPoints">equalPoints</a></li><li><a href="global.html#error">error</a></li><li><a href="global.html#extractTextWithWhitespace">extractTextWithWhitespace</a></li><li><a href="global.html#findNearestSegment">findNearestSegment</a></li><li><a href="global.html#findNode">findNode</a></li><li><a href="global.html#findTreeRoots">findTreeRoots</a></li><li><a href="global.html#fit">fit</a></li><li><a href="global.html#FONT">FONT</a></li><li><a href="global.html#get">get</a></li><li><a href="global.html#getAlignmentAsPoint">getAlignmentAsPoint</a></li><li><a href="global.html#getAll">getAll</a></li><li><a href="global.html#getBoundingBox">getBoundingBox</a></li><li><a href="global.html#getChildNodes">getChildNodes</a></li><li><a href="global.html#getClientX">getClientX</a></li><li><a href="global.html#getClientY">getClientY</a></li><li><a href="global.html#getColor">getColor</a></li><li><a href="global.html#getCurrentStyle">getCurrentStyle</a></li><li><a href="global.html#getDirectedBounds">getDirectedBounds</a></li><li><a href="global.html#getDocumentScrollOrigin">getDocumentScrollOrigin</a></li><li><a href="global.html#getDocumentSize">getDocumentSize</a></li><li><a href="global.html#getFunctionName">getFunctionName</a></li><li><a href="global.html#getInnerHtml">getInnerHtml</a></li><li><a href="global.html#getNumber">getNumber</a></li><li><a href="global.html#getOffset">getOffset</a></li><li><a href="global.html#getOuterHtml">getOuterHtml</a></li><li><a href="global.html#getPerimeterPoint">getPerimeterPoint</a></li><li><a href="global.html#getPortConstraints">getPortConstraints</a></li><li><a href="global.html#getPrettyXml">getPrettyXml</a></li><li><a href="global.html#getRotatedPoint">getRotatedPoint</a></li><li><a href="global.html#getScaleForPageCount">getScaleForPageCount</a></li><li><a href="global.html#getScrollOrigin">getScrollOrigin</a></li><li><a href="global.html#getSizeForString">getSizeForString</a></li><li><a href="global.html#getSource">getSource</a></li><li><a href="global.html#getStylename">getStylename</a></li><li><a href="global.html#getStylenames">getStylenames</a></li><li><a href="global.html#getTextContent">getTextContent</a></li><li><a href="global.html#getValue">getValue</a></li><li><a href="global.html#getXml">getXml</a></li><li><a href="global.html#GUIDE_COLOR">GUIDE_COLOR</a></li><li><a href="global.html#GUIDE_STROKEWIDTH">GUIDE_STROKEWIDTH</a></li><li><a href="global.html#HANDLE_FILLCOLOR">HANDLE_FILLCOLOR</a></li><li><a href="global.html#HANDLE_SIZE">HANDLE_SIZE</a></li><li><a href="global.html#HANDLE_STROKECOLOR">HANDLE_STROKECOLOR</a></li><li><a href="global.html#hasScrollbars">hasScrollbars</a></li><li><a href="global.html#HIGHLIGHT_COLOR">HIGHLIGHT_COLOR</a></li><li><a href="global.html#HIGHLIGHT_OPACITY">HIGHLIGHT_OPACITY</a></li><li><a href="global.html#HIGHLIGHT_SIZE">HIGHLIGHT_SIZE</a></li><li><a href="global.html#HIGHLIGHT_STROKEWIDTH">HIGHLIGHT_STROKEWIDTH</a></li><li><a href="global.html#htmlEntities">htmlEntities</a></li><li><a href="global.html#importNode">importNode</a></li><li><a href="global.html#importNodeImplementation">importNodeImplementation</a></li><li><a href="global.html#indexOfStylename">indexOfStylename</a></li><li><a href="global.html#intersection">intersection</a></li><li><a href="global.html#intersects">intersects</a></li><li><a href="global.html#intersectsHotspot">intersectsHotspot</a></li><li><a href="global.html#INVALID_COLOR">INVALID_COLOR</a></li><li><a href="global.html#INVALID_CONNECT_TARGET_COLOR">INVALID_CONNECT_TARGET_COLOR</a></li><li><a href="global.html#isAltDown">isAltDown</a></li><li><a href="global.html#isAncestorNode">isAncestorNode</a></li><li><a href="global.html#isConsumed">isConsumed</a></li><li><a href="global.html#isControlDown">isControlDown</a></li><li><a href="global.html#isInteger">isInteger</a></li><li><a href="global.html#isLeftMouseButton">isLeftMouseButton</a></li><li><a href="global.html#isMetaDown">isMetaDown</a></li><li><a href="global.html#isMiddleMouseButton">isMiddleMouseButton</a></li><li><a href="global.html#isMouseEvent">isMouseEvent</a></li><li><a href="global.html#isMultiTouchEvent">isMultiTouchEvent</a></li><li><a href="global.html#isNode">isNode</a></li><li><a href="global.html#isNumeric">isNumeric</a></li><li><a href="global.html#isPenEvent">isPenEvent</a></li><li><a href="global.html#isPopupTrigger">isPopupTrigger</a></li><li><a href="global.html#isRightMouseButton">isRightMouseButton</a></li><li><a href="global.html#isShiftDown">isShiftDown</a></li><li><a href="global.html#isTouchEvent">isTouchEvent</a></li><li><a href="global.html#LABEL_HANDLE_FILLCOLOR">LABEL_HANDLE_FILLCOLOR</a></li><li><a href="global.html#LABEL_HANDLE_SIZE">LABEL_HANDLE_SIZE</a></li><li><a href="global.html#LINE_ARCSIZE">LINE_ARCSIZE</a></li><li><a href="global.html#LINE_HEIGHT">LINE_HEIGHT</a></li><li><a href="global.html#link">link</a></li><li><a href="global.html#linkAction">linkAction</a></li><li><a href="global.html#linkInvoke">linkInvoke</a></li><li><a href="global.html#load">load</a></li><li><a href="global.html#LOCKED_HANDLE_FILLCOLOR">LOCKED_HANDLE_FILLCOLOR</a></li><li><a href="global.html#ltrim">ltrim</a></li><li><a href="global.html#makeDraggable">makeDraggable</a></li><li><a href="global.html#MAX_HOTSPOT_SIZE">MAX_HOTSPOT_SIZE</a></li><li><a href="global.html#MIN_HOTSPOT_SIZE">MIN_HOTSPOT_SIZE</a></li><li><a href="global.html#mod">mod</a></li><li><a href="global.html#NONE">NONE</a></li><li><a href="global.html#NS_SVG">NS_SVG</a></li><li><a href="global.html#NS_XLINK">NS_XLINK</a></li><li><a href="global.html#OUTLINE_COLOR">OUTLINE_COLOR</a></li><li><a href="global.html#OUTLINE_HANDLE_FILLCOLOR">OUTLINE_HANDLE_FILLCOLOR</a></li><li><a href="global.html#OUTLINE_HANDLE_STROKECOLOR">OUTLINE_HANDLE_STROKECOLOR</a></li><li><a href="global.html#OUTLINE_HIGHLIGHT_COLOR">OUTLINE_HIGHLIGHT_COLOR</a></li><li><a href="global.html#OUTLINE_HIGHLIGHT_STROKEWIDTH">OUTLINE_HIGHLIGHT_STROKEWIDTH</a></li><li><a href="global.html#OUTLINE_STROKEWIDTH">OUTLINE_STROKEWIDTH</a></li><li><a href="global.html#PAGE_FORMAT_A4_LANDSCAPE">PAGE_FORMAT_A4_LANDSCAPE</a></li><li><a href="global.html#PAGE_FORMAT_A4_PORTRAIT">PAGE_FORMAT_A4_PORTRAIT</a></li><li><a href="global.html#PAGE_FORMAT_LETTER_LANDSCAPE">PAGE_FORMAT_LETTER_LANDSCAPE</a></li><li><a href="global.html#PAGE_FORMAT_LETTER_PORTRAIT">PAGE_FORMAT_LETTER_PORTRAIT</a></li><li><a href="global.html#para">para</a></li><li><a href="global.html#parseCssNumber">parseCssNumber</a></li><li><a href="global.html#PERIMETER">PERIMETER</a></li><li><a href="global.html#popup">popup</a></li><li><a href="global.html#post">post</a></li><li><a href="global.html#printScreen">printScreen</a></li><li><a href="global.html#ptLineDist">ptLineDist</a></li><li><a href="global.html#ptSegDistSq">ptSegDistSq</a></li><li><a href="global.html#RECTANGLE_ROUNDING_FACTOR">RECTANGLE_ROUNDING_FACTOR</a></li><li><a href="global.html#rectangleIntersectsSegment">rectangleIntersectsSegment</a></li><li><a href="global.html#relativeCcw">relativeCcw</a></li><li><a href="global.html#remove">remove</a></li><li><a href="global.html#removeAllStylenames">removeAllStylenames</a></li><li><a href="global.html#removeCursors">removeCursors</a></li><li><a href="global.html#removeDuplicates">removeDuplicates</a></li><li><a href="global.html#removeStylename">removeStylename</a></li><li><a href="global.html#removeWhitespace">removeWhitespace</a></li><li><a href="global.html#RENDERING_HINT">RENDERING_HINT</a></li><li><a href="global.html#replaceTrailingNewlines">replaceTrailingNewlines</a></li><li><a href="global.html#reversePortConstraints">reversePortConstraints</a></li><li><a href="global.html#rtrim">rtrim</a></li><li><a href="global.html#setCellStyleFlags">setCellStyleFlags</a></li><li><a href="global.html#setCellStyles">setCellStyles</a></li><li><a href="global.html#setOpacity">setOpacity</a></li><li><a href="global.html#setPrefixedStyle">setPrefixedStyle</a></li><li><a href="global.html#setStyle">setStyle</a></li><li><a href="global.html#setStyleFlag">setStyleFlag</a></li><li><a href="global.html#setTextContent">setTextContent</a></li><li><a href="global.html#SHADOW_OFFSET_X">SHADOW_OFFSET_X</a></li><li><a href="global.html#SHADOW_OFFSET_Y">SHADOW_OFFSET_Y</a></li><li><a href="global.html#SHADOW_OPACITY">SHADOW_OPACITY</a></li><li><a href="global.html#SHADOWCOLOR">SHADOWCOLOR</a></li><li><a href="global.html#show">show</a></li><li><a href="global.html#sortCells">sortCells</a></li><li><a href="global.html#submit">submit</a></li><li><a href="global.html#TEXT_DIRECTION">TEXT_DIRECTION</a></li><li><a href="global.html#toDegree">toDegree</a></li><li><a href="global.html#TOOLTIP_VERTICAL_OFFSET">TOOLTIP_VERTICAL_OFFSET</a></li><li><a href="global.html#toRadians">toRadians</a></li><li><a href="global.html#toString">toString</a></li><li><a href="global.html#traverse">traverse</a></li><li><a href="global.html#trim">trim</a></li><li><a href="global.html#utils">utils</a></li><li><a href="global.html#VALID_COLOR">VALID_COLOR</a></li><li><a href="global.html#VERTEX_SELECTION_COLOR">VERTEX_SELECTION_COLOR</a></li><li><a href="global.html#VERTEX_SELECTION_DASHED">VERTEX_SELECTION_DASHED</a></li><li><a href="global.html#VERTEX_SELECTION_STROKEWIDTH">VERTEX_SELECTION_STROKEWIDTH</a></li><li><a href="global.html#WORD_WRAP">WORD_WRAP</a></li><li><a href="global.html#write">write</a></li><li><a href="global.html#writeln">writeln</a></li></ul></div>
                
            </nav>
        </div>
        <div class="core" id="main-content-wrapper">
            <div class="content">
                <header class="page-title">
                    <p>Source</p>
                    <h1>view/handler/VertexHandler.ts</h1>
                </header>
                



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Copyright (c) 2006-2015, JGraph Ltd
 * Copyright (c) 2006-2015, Gaudenz Alder
 * Updated to ES9 syntax by David Morrissey 2021
 * Type definitions from the typed-mxgraph project
 */
import Rectangle from '../geometry/Rectangle';
import {
  CURSOR,
  DIALECT,
  HANDLE_FILLCOLOR,
  HANDLE_SIZE,
  HANDLE_STROKECOLOR,
  LABEL_HANDLE_FILLCOLOR,
  LABEL_HANDLE_SIZE,
  NONE,
  VERTEX_SELECTION_COLOR,
  VERTEX_SELECTION_DASHED,
  VERTEX_SELECTION_STROKEWIDTH,
} from '../../util/constants';
import InternalEvent from '../event/InternalEvent';
import RectangleShape from '../geometry/node/RectangleShape';
import ImageShape from '../geometry/node/ImageShape';
import EllipseShape from '../geometry/node/EllipseShape';
import Point from '../geometry/Point';
import { getRotatedPoint, intersects, mod, toRadians } from '../../util/mathUtils';
import Client from '../../Client';
import { isMouseEvent, isShiftDown } from '../../util/eventUtils';
import { Graph } from '../Graph';
import CellState from '../cell/CellState';
import Image from '../image/ImageBox';
import Cell from '../cell/Cell';
import { CellHandle, Listenable } from '../../types';
import Shape from '../geometry/Shape';
import InternalMouseEvent from '../event/InternalMouseEvent';
import CellArray from '../cell/CellArray';
import EdgeHandler from './EdgeHandler';
import EventSource from '../event/EventSource';
import SelectionHandler from './SelectionHandler';
import SelectionCellsHandler from './SelectionCellsHandler';

/**
 * Event handler for resizing cells. This handler is automatically created in
 * &lt;mxGraph.createHandler>.
 *
 * Constructor: mxVertexHandler
 *
 * Constructs an event handler that allows to resize vertices
 * and groups.
 *
 * @param state &lt;CellState> of the cell to be resized.
 */
class VertexHandler {
  escapeHandler: (sender: Listenable, evt: Event) => void;
  selectionBounds: Rectangle;
  bounds: Rectangle;
  selectionBorder: RectangleShape;

  /**
   * Reference to the enclosing &lt;mxGraph>.
   */
  graph: Graph;

  /**
   * Reference to the &lt;CellState> being modified.
   */
  state: CellState;

  sizers: Shape[] = [];

  /**
   * Specifies if only one sizer handle at the bottom, right corner should be
   * used. Default is false.
   */
  singleSizer: boolean = false;

  /**
   * Holds the index of the current handle.
   */
  index: number | null = null;

  /**
   * Specifies if the bounds of handles should be used for hit-detection in IE or
   * if &lt;tolerance> > 0. Default is true.
   */
  allowHandleBoundsCheck: boolean = true;

  /**
   * Optional &lt;mxImage> to be used as handles. Default is null.
   */
  handleImage: Image | null = null;

  /**
   * If handles are currently visible.
   */
  handlesVisible = true;

  /**
   * Optional tolerance for hit-detection in &lt;getHandleForEvent>. Default is 0.
   */
  tolerance: number = 0;

  /**
   * Specifies if a rotation handle should be visible. Default is false.
   */
  rotationEnabled: boolean = false;

  /**
   * Specifies if the parent should be highlighted if a child cell is selected.
   * Default is false.
   */
  parentHighlightEnabled: boolean = false;

  /**
   * Specifies if rotation steps should be "rasterized" depening on the distance
   * to the handle. Default is true.
   */
  rotationRaster: boolean = true;

  /**
   * Specifies the cursor for the rotation handle. Default is 'crosshair'.
   */
  rotationCursor: string = 'crosshair';

  /**
   * Specifies if resize should change the cell in-place. This is an experimental
   * feature for non-touch devices. Default is false.
   */
  livePreview: boolean = false;

  /**
   * Specifies if the live preview should be moved to the front.
   */
  movePreviewToFront: boolean = false;

  /**
   * Specifies if sizers should be hidden and spaced if the vertex is small.
   * Default is false.
   */
  manageSizers: boolean = false;

  /**
   * Specifies if the size of groups should be constrained by the children.
   * Default is false.
   */
  constrainGroupByChildren: boolean = false;

  /**
   * Vertical spacing for rotation icon. Default is -16.
   */
  rotationHandleVSpacing: number = -16;

  /**
   * The horizontal offset for the handles. This is updated in &lt;redrawHandles>
   * if &lt;manageSizers> is true and the sizers are offset horizontally.
   */
  horizontalOffset: number = 0;

  /**
   * The horizontal offset for the handles. This is updated in &lt;redrawHandles>
   * if &lt;manageSizers> is true and the sizers are offset vertically.
   */
  verticalOffset: number = 0;

  minBounds: Rectangle | null = null;

  x0 = 0;
  y0 = 0;

  customHandles: CellHandle[] = [];

  inTolerance = false;

  startX = 0;
  startY = 0;

  rotationShape: Shape | null = null;

  currentAlpha = 100;
  startAngle = 0;
  startDist = 0;

  ghostPreview: Shape | null = null;

  livePreviewActive = false;

  childOffsetX = 0;
  childOffsetY = 0;

  parentState: CellState | null = null;
  parentHighlight: RectangleShape | null = null;

  unscaledBounds: Rectangle | null = null;

  preview: Shape | null = null;

  labelShape: Shape | null = null;

  edgeHandlers: EdgeHandler[] = [];

  EMPTY_POINT = new Point();

  constructor(state: CellState) {
    this.state = state;
    this.graph = (&lt;Graph>this.state.view.graph);
    this.selectionBounds = this.getSelectionBounds(this.state);
    this.bounds = new Rectangle(
      this.selectionBounds.x,
      this.selectionBounds.y,
      this.selectionBounds.width,
      this.selectionBounds.height
    );
    this.selectionBorder = this.createSelectionShape(this.bounds);
    // VML dialect required here for event transparency in IE
    this.selectionBorder.dialect = DIALECT.SVG;
    this.selectionBorder.pointerEvents = false;
    this.selectionBorder.rotation = this.state.style.rotation ?? 0;
    this.selectionBorder.init(this.graph.getView().getOverlayPane());
    InternalEvent.redirectMouseEvents(this.selectionBorder.node, this.graph, this.state);

    if (this.graph.isCellMovable(this.state.cell)) {
      this.selectionBorder.setCursor(CURSOR.MOVABLE_VERTEX);
    }

    const graphHandler = this.graph.getPlugin('SelectionHandler') as SelectionHandler;

    // Adds the sizer handles
    if (
      graphHandler.maxCells &lt;= 0 ||
      this.graph.getSelectionCount() &lt; graphHandler.maxCells
    ) {
      const resizable = this.graph.isCellResizable(this.state.cell);
      this.sizers = [];

      if (
        resizable ||
        (this.graph.isLabelMovable(this.state.cell) &amp;&amp;
          this.state.width >= 2 &amp;&amp;
          this.state.height >= 2)
      ) {
        let i = 0;

        if (resizable) {
          if (!this.singleSizer) {
            this.sizers.push(this.createSizer('nw-resize', i++));
            this.sizers.push(this.createSizer('n-resize', i++));
            this.sizers.push(this.createSizer('ne-resize', i++));
            this.sizers.push(this.createSizer('w-resize', i++));
            this.sizers.push(this.createSizer('e-resize', i++));
            this.sizers.push(this.createSizer('sw-resize', i++));
            this.sizers.push(this.createSizer('s-resize', i++));
          }

          this.sizers.push(this.createSizer('se-resize', i++));
        }

        const geo = this.state.cell.getGeometry();

        if (
          geo != null &amp;&amp;
          !geo.relative &amp;&amp;
          //!this.graph.isSwimlane(this.state.cell) &amp;&amp;      disable for now
          this.graph.isLabelMovable(this.state.cell)
        ) {
          // Marks this as the label handle for getHandleForEvent
          this.labelShape = this.createSizer(
            CURSOR.LABEL_HANDLE,
            InternalEvent.LABEL_HANDLE,
            LABEL_HANDLE_SIZE,
            LABEL_HANDLE_FILLCOLOR
          );
          this.sizers.push(this.labelShape);
        }
      } else if (
        this.graph.isCellMovable(this.state.cell) &amp;&amp;
        !this.graph.isCellResizable(this.state.cell) &amp;&amp;
        this.state.width &lt; 2 &amp;&amp;
        this.state.height &lt; 2
      ) {
        this.labelShape = this.createSizer(
          CURSOR.MOVABLE_VERTEX,
          InternalEvent.LABEL_HANDLE,
          undefined,
          LABEL_HANDLE_FILLCOLOR
        );
        this.sizers.push(this.labelShape);
      }
    }

    // Adds the rotation handler
    if (this.isRotationHandleVisible()) {
      this.rotationShape = this.createSizer(
        this.rotationCursor,
        InternalEvent.ROTATION_HANDLE,
        HANDLE_SIZE + 3,
        HANDLE_FILLCOLOR
      );
      this.sizers.push(this.rotationShape);
    }

    this.customHandles = this.createCustomHandles();
    this.redraw();

    if (this.constrainGroupByChildren) {
      this.updateMinBounds();
    }

    // Handles escape keystrokes
    this.escapeHandler = (sender: Listenable, evt: Event) => {
      if (this.livePreview &amp;&amp; this.index != null) {
        // Redraws the live preview
        (&lt;Graph>this.state.view.graph).cellRenderer.redraw(this.state, true);

        // Redraws connected edges
        this.state.view.invalidate(this.state.cell);
        this.state.invalid = false;
        this.state.view.validate();
      }

      this.reset();
    };

    (&lt;Graph>this.state.view.graph).addListener(InternalEvent.ESCAPE, this.escapeHandler);
  }

  /**
   * Returns true if the rotation handle should be showing.
   */
  isRotationHandleVisible() {
    const graphHandler = this.graph.getPlugin('SelectionHandler') as SelectionHandler;

    return (
      this.graph.isEnabled() &amp;&amp;
      this.rotationEnabled &amp;&amp;
      this.graph.isCellRotatable(this.state.cell) &amp;&amp;
      (graphHandler.maxCells &lt;= 0 ||
        this.graph.getSelectionCount() &lt; graphHandler.maxCells)
    );
  }

  /**
   * Returns true if the aspect ratio if the cell should be maintained.
   */
  isConstrainedEvent(me: InternalMouseEvent) {
    return isShiftDown(me.getEvent()) || this.state.style.aspect === 'fixed';
  }

  /**
   * Returns true if the center of the vertex should be maintained during the resize.
   */
  isCenteredEvent(state: CellState, me: InternalMouseEvent) {
    return false;
  }

  /**
   * Returns an array of custom handles. This implementation returns null.
   */
  createCustomHandles() {
    return [];
  }

  /**
   * Initializes the shapes required for this vertex handler.
   */
  updateMinBounds() {
    const children = this.graph.getChildCells(this.state.cell);

    if (children.length > 0) {
      this.minBounds = this.graph.view.getBounds(children);

      if (this.minBounds) {
        const s = this.state.view.scale;
        const t = this.state.view.translate;

        this.minBounds.x -= this.state.x;
        this.minBounds.y -= this.state.y;
        this.minBounds.x /= s;
        this.minBounds.y /= s;
        this.minBounds.width /= s;
        this.minBounds.height /= s;
        this.x0 = this.state.x / s - t.x;
        this.y0 = this.state.y / s - t.y;
      }
    }
  }

  /**
   * Returns the mxRectangle that defines the bounds of the selection
   * border.
   */
  getSelectionBounds(state: CellState) {
    return new Rectangle(
      Math.round(state.x),
      Math.round(state.y),
      Math.round(state.width),
      Math.round(state.height)
    );
  }

  /**
   * Creates the shape used to draw the selection border.
   */
  createParentHighlightShape(bounds: Rectangle) {
    return this.createSelectionShape(bounds);
  }

  /**
   * Creates the shape used to draw the selection border.
   */
  createSelectionShape(bounds: Rectangle) {
    const shape = new RectangleShape(
      Rectangle.fromRectangle(bounds),
      NONE,
      this.getSelectionColor()
    );
    shape.strokeWidth = this.getSelectionStrokeWidth();
    shape.isDashed = this.isSelectionDashed();

    return shape;
  }

  /**
   * Returns &lt;mxConstants.VERTEX_SELECTION_COLOR>.
   */
  getSelectionColor() {
    return VERTEX_SELECTION_COLOR;
  }

  /**
   * Returns &lt;mxConstants.VERTEX_SELECTION_STROKEWIDTH>.
   */
  getSelectionStrokeWidth() {
    return VERTEX_SELECTION_STROKEWIDTH;
  }

  /**
   * Returns &lt;mxConstants.VERTEX_SELECTION_DASHED>.
   */
  isSelectionDashed() {
    return VERTEX_SELECTION_DASHED;
  }

  /**
   * Creates a sizer handle for the specified cursor and index and returns
   * the new &lt;mxRectangleShape> that represents the handle.
   */
  createSizer(
    cursor: string,
    index: number,
    size = HANDLE_SIZE,
    fillColor = HANDLE_FILLCOLOR
  ) {
    const bounds = new Rectangle(0, 0, size, size);
    const sizer = this.createSizerShape(bounds, index, fillColor);

    if (
      sizer.bounds &amp;&amp;
      sizer.isHtmlAllowed() &amp;&amp;
      this.state.text &amp;&amp;
      this.state.text.node.parentNode === this.graph.container
    ) {
      sizer.bounds.height -= 1;
      sizer.bounds.width -= 1;
      sizer.dialect = DIALECT.STRICTHTML;
      sizer.init(this.graph.container);
    } else {
      sizer.dialect =
        this.graph.dialect !== DIALECT.SVG ? DIALECT.MIXEDHTML : DIALECT.SVG;
      sizer.init(this.graph.getView().getOverlayPane());
    }

    InternalEvent.redirectMouseEvents(sizer.node, this.graph, this.state);

    if (this.graph.isEnabled()) {
      sizer.setCursor(cursor);
    }

    if (!this.isSizerVisible(index)) {
      sizer.visible = false;
    }

    return sizer;
  }

  /**
   * Returns true if the sizer for the given index is visible.
   * This returns true for all given indices.
   */
  isSizerVisible(index: number) {
    return true;
  }

  /**
   * Creates the shape used for the sizer handle for the specified bounds an
   * index. Only images and rectangles should be returned if support for HTML
   * labels with not foreign objects is required.
   */
  createSizerShape(bounds: Rectangle, index: number, fillColor = HANDLE_FILLCOLOR) {
    if (this.handleImage) {
      bounds = new Rectangle(
        bounds.x,
        bounds.y,
        this.handleImage.width,
        this.handleImage.height
      );
      const shape = new ImageShape(bounds, this.handleImage.src);

      // Allows HTML rendering of the images
      shape.preserveImageAspect = false;

      return shape;
    }
    if (index === InternalEvent.ROTATION_HANDLE) {
      return new EllipseShape(bounds, fillColor, HANDLE_STROKECOLOR);
    }
    return new RectangleShape(bounds, fillColor, HANDLE_STROKECOLOR);
  }

  /**
   * Helper method to create an &lt;mxRectangle> around the given centerpoint
   * with a width and height of 2*s or 6, if no s is given.
   */
  moveSizerTo(shape: Shape, x: number, y: number) {
    if (shape &amp;&amp; shape.bounds) {
      shape.bounds.x = Math.floor(x - shape.bounds.width / 2);
      shape.bounds.y = Math.floor(y - shape.bounds.height / 2);

      // Fixes visible inactive handles in VML
      if (shape.node &amp;&amp; shape.node.style.display !== 'none') {
        shape.redraw();
      }
    }
  }

  /**
   * Returns the index of the handle for the given event. This returns the index
   * of the sizer from where the event originated or &lt;mxEvent.LABEL_INDEX>.
   */
  getHandleForEvent(me: InternalMouseEvent) {
    // Connection highlight may consume events before they reach sizer handle
    const tol = !isMouseEvent(me.getEvent()) ? this.tolerance : 1;
    const hit =
      this.allowHandleBoundsCheck &amp;&amp; tol > 0
        ? new Rectangle(me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol)
        : null;

    const checkShape = (shape: Shape | null) => {
      const st =
        shape &amp;&amp; shape.constructor !== ImageShape &amp;&amp; this.allowHandleBoundsCheck
          ? shape.strokeWidth + shape.svgStrokeTolerance
          : null;
      const real = st
        ? new Rectangle(
            me.getGraphX() - Math.floor(st / 2),
            me.getGraphY() - Math.floor(st / 2),
            st,
            st
          )
        : hit;

      return (
        shape &amp;&amp;
        shape.bounds &amp;&amp;
        (me.isSource(shape) ||
          (real &amp;&amp;
            intersects(shape.bounds, real) &amp;&amp;
            shape.node.style.display !== 'none' &amp;&amp;
            shape.node.style.visibility !== 'hidden'))
      );
    };

    if (checkShape(this.rotationShape)) {
      return InternalEvent.ROTATION_HANDLE;
    }
    if (checkShape(this.labelShape)) {
      return InternalEvent.LABEL_HANDLE;
    }

    for (let i = 0; i &lt; this.sizers.length; i += 1) {
      if (checkShape(this.sizers[i])) {
        return i;
      }
    }

    if (this.customHandles != null &amp;&amp; this.isCustomHandleEvent(me)) {
      // Inverse loop order to match display order
      for (let i = this.customHandles.length - 1; i >= 0; i--) {
        if (checkShape(this.customHandles[i].shape)) {
          // LATER: Return reference to active shape
          return InternalEvent.CUSTOM_HANDLE - i;
        }
      }
    }

    return null;
  }

  /**
   * Returns true if the given event allows custom handles to be changed. This
   * implementation returns true.
   */
  isCustomHandleEvent(me: InternalMouseEvent) {
    return true;
  }

  /**
   * Handles the event if a handle has been clicked. By consuming the
   * event all subsequent events of the gesture are redirected to this
   * handler.
   */
  mouseDown(sender: EventSource, me: InternalMouseEvent) {
    if (!me.isConsumed() &amp;&amp; this.graph.isEnabled()) {
      const handle = this.getHandleForEvent(me);

      if (handle) {
        this.start(me.getGraphX(), me.getGraphY(), handle);
        me.consume();
      }
    }
  }

  /**
   * Called if &lt;livePreview> is enabled to check if a border should be painted.
   * This implementation returns true if the shape is transparent.
   */
  isLivePreviewBorder() {
    return (
      this.state.shape &amp;&amp;
      this.state.shape.fill === NONE &amp;&amp;
      this.state.shape.stroke === NONE
    );
  }

  /**
   * Starts the handling of the mouse gesture.
   */
  start(x: number, y: number, index: number) {
    this.livePreviewActive = this.livePreview &amp;&amp; this.state.cell.getChildCount() === 0;
    this.inTolerance = true;
    this.childOffsetX = 0;
    this.childOffsetY = 0;
    this.index = index;
    this.startX = x;
    this.startY = y;

    if (this.index &lt;= InternalEvent.CUSTOM_HANDLE &amp;&amp; this.isGhostPreview()) {
      this.ghostPreview = this.createGhostPreview();
    } else {
      // Saves reference to parent state
      const { model } = (&lt;Graph>this.state.view.graph);
      const parent = this.state.cell.getParent();

      if (
        this.state.view.currentRoot !== parent &amp;&amp;
        parent &amp;&amp;
        (parent.isVertex() || parent.isEdge())
      ) {
        this.parentState = (&lt;Graph>this.state.view.graph).view.getState(parent);
      }

      // Creates a preview that can be on top of any HTML label
      this.selectionBorder.node.style.display =
        index === InternalEvent.ROTATION_HANDLE ? 'inline' : 'none';

      // Creates the border that represents the new bounds
      if (!this.livePreviewActive || this.isLivePreviewBorder()) {
        this.preview = this.createSelectionShape(this.bounds);

        if (
          !(Client.IS_SVG &amp;&amp; Number(this.state.style.rotation || '0') !== 0) &amp;&amp;
          this.state.text != null &amp;&amp;
          this.state.text.node.parentNode === this.graph.container
        ) {
          this.preview.dialect = DIALECT.STRICTHTML;
          this.preview.init(this.graph.container);
        } else {
          this.preview.dialect = DIALECT.SVG;
          this.preview.init(this.graph.view.getOverlayPane());
        }
      }

      if (index === InternalEvent.ROTATION_HANDLE) {
        // With the rotation handle in a corner, need the angle and distance
        const pos = this.getRotationHandlePosition();

        const dx = pos.x - this.state.getCenterX();
        const dy = pos.y - this.state.getCenterY();

        this.startAngle = dx !== 0 ? (Math.atan(dy / dx) * 180) / Math.PI + 90 : 0;
        this.startDist = Math.sqrt(dx * dx + dy * dy);
      }

      // Prepares the handles for live preview
      if (this.livePreviewActive) {
        this.hideSizers();

        if (index === InternalEvent.ROTATION_HANDLE &amp;&amp; this.rotationShape) {
          this.rotationShape.node.style.display = '';
        } else if (index === InternalEvent.LABEL_HANDLE &amp;&amp; this.labelShape) {
          this.labelShape.node.style.display = '';
        } else if (this.sizers[index]) {
          this.sizers[index].node.style.display = '';
        } else if (index &lt;= InternalEvent.CUSTOM_HANDLE) {
          this.customHandles[InternalEvent.CUSTOM_HANDLE - index].setVisible(true);
        }

        // Gets the array of connected edge handlers for redrawing
        const edges = this.state.cell.getEdges();
        this.edgeHandlers = [];

        const selectionCellsHandler = this.graph.getPlugin(
          'SelectionCellsHandler'
        ) as SelectionCellsHandler;

        for (let i = 0; i &lt; edges.length; i += 1) {
          const handler = selectionCellsHandler.getHandler(edges[i]);

          if (handler) {
            this.edgeHandlers.push(handler as EdgeHandler);
          }
        }
      }
    }
  }

  /**
   * Starts the handling of the mouse gesture.
   */
  createGhostPreview() {
    const shape = this.graph.cellRenderer.createShape(this.state);
    shape.init(this.graph.view.getOverlayPane());
    shape.scale = this.state.view.scale;
    shape.bounds = this.bounds;
    shape.outline = true;

    return shape;
  }

  /**
   * Shortcut to &lt;hideSizers>.
   */
  setHandlesVisible(visible: boolean) {
    this.handlesVisible = visible;

    for (let i = 0; i &lt; this.sizers.length; i += 1) {
      this.sizers[i].node.style.display = visible ? '' : 'none';
    }

    for (let i = 0; i &lt; this.customHandles.length; i += 1) {
      this.customHandles[i].setVisible(visible);
    }
  }

  /**
   * Hides all sizers except.
   *
   * Starts the handling of the mouse gesture.
   */
  hideSizers() {
    this.setHandlesVisible(false);
  }

  /**
   * Checks if the coordinates for the given event are within the
   * &lt;mxGraph.tolerance>. If the event is a mouse event then the tolerance is
   * ignored.
   */
  checkTolerance(me: InternalMouseEvent) {
    if (this.inTolerance &amp;&amp; this.startX !== null &amp;&amp; this.startY !== null) {
      if (
        isMouseEvent(me.getEvent()) ||
        Math.abs(me.getGraphX() - this.startX) > this.graph.getEventTolerance() ||
        Math.abs(me.getGraphY() - this.startY) > this.graph.getEventTolerance()
      ) {
        this.inTolerance = false;
      }
    }
  }

  /**
   * Hook for subclassers do show details while the handler is active.
   */
  updateHint(me: InternalMouseEvent) {}

  /**
   * Hooks for subclassers to hide details when the handler gets inactive.
   */
  removeHint() {}

  /**
   * Hook for rounding the angle. This uses Math.round.
   */
  // roundAngle(angle: number): number;
  roundAngle(angle: number) {
    return Math.round(angle * 10) / 10;
  }

  /**
   * Hook for rounding the unscaled width or height. This uses Math.round.
   */
  roundLength(length: number) {
    return Math.round(length * 100) / 100;
  }

  /**
   * Handles the event by updating the preview.
   */
  mouseMove(sender: EventSource, me: InternalMouseEvent) {
    if (!me.isConsumed() &amp;&amp; this.index != null) {
      // Checks tolerance for ignoring single clicks
      this.checkTolerance(me);

      if (!this.inTolerance) {
        if (this.index &lt;= InternalEvent.CUSTOM_HANDLE) {
          if (this.customHandles != null) {
            this.customHandles[InternalEvent.CUSTOM_HANDLE - this.index].processEvent(me);
            this.customHandles[InternalEvent.CUSTOM_HANDLE - this.index].active = true;

            if (this.ghostPreview != null) {
              this.ghostPreview.apply(this.state);
              this.ghostPreview.strokeWidth =
                this.getSelectionStrokeWidth() /
                this.ghostPreview.scale /
                this.ghostPreview.scale;
              this.ghostPreview.isDashed = this.isSelectionDashed();
              this.ghostPreview.stroke = this.getSelectionColor();
              this.ghostPreview.redraw();

              if (this.selectionBounds != null) {
                this.selectionBorder.node.style.display = 'none';
              }
            } else {
              if (this.movePreviewToFront) {
                this.moveToFront();
              }

              this.customHandles[
                InternalEvent.CUSTOM_HANDLE - this.index
              ].positionChanged();
            }
          }
        } else if (this.index === InternalEvent.LABEL_HANDLE) {
          this.moveLabel(me);
        } else {
          if (this.index === InternalEvent.ROTATION_HANDLE) {
            this.rotateVertex(me);
          } else {
            this.resizeVertex(me);
          }

          this.updateHint(me);
        }
      }

      me.consume();
    }
    // Workaround for disabling the connect highlight when over handle
    else if (!this.graph.isMouseDown &amp;&amp; this.getHandleForEvent(me)) {
      me.consume(false);
    }
  }

  /**
   * Returns true if a ghost preview should be used for custom handles.
   */
  isGhostPreview() {
    return this.state.cell.getChildCount() > 0;
  }

  /**
   * Rotates the vertex.
   */
  moveLabel(me: InternalMouseEvent) {
    const point = new Point(me.getGraphX(), me.getGraphY());
    const tr = this.graph.view.translate;
    const { scale } = this.graph.view;

    if (this.graph.isGridEnabledEvent(me.getEvent())) {
      point.x = (this.graph.snap(point.x / scale - tr.x) + tr.x) * scale;
      point.y = (this.graph.snap(point.y / scale - tr.y) + tr.y) * scale;
    }

    const index = this.rotationShape ? this.sizers.length - 2 : this.sizers.length - 1;
    this.moveSizerTo(this.sizers[index], point.x, point.y);
  }

  /**
   * Rotates the vertex.
   */
  rotateVertex(me: InternalMouseEvent) {
    const point = new Point(me.getGraphX(), me.getGraphY());
    let dx = this.state.x + this.state.width / 2 - point.x;
    let dy = this.state.y + this.state.height / 2 - point.y;
    this.currentAlpha =
      dx !== 0 ? (Math.atan(dy / dx) * 180) / Math.PI + 90 : dy &lt; 0 ? 180 : 0;

    if (dx > 0) {
      this.currentAlpha -= 180;
    }

    this.currentAlpha -= this.startAngle;

    // Rotation raster
    if (this.rotationRaster &amp;&amp; this.graph.isGridEnabledEvent(me.getEvent())) {
      let raster;
      dx = point.x - this.state.getCenterX();
      dy = point.y - this.state.getCenterY();
      const dist = Math.sqrt(dx * dx + dy * dy);

      if (dist - this.startDist &lt; 2) {
        raster = 15;
      } else if (dist - this.startDist &lt; 25) {
        raster = 5;
      } else {
        raster = 1;
      }

      this.currentAlpha = Math.round(this.currentAlpha / raster) * raster;
    } else {
      this.currentAlpha = this.roundAngle(this.currentAlpha);
    }

    this.selectionBorder.rotation = this.currentAlpha;
    this.selectionBorder.redraw();

    if (this.livePreviewActive) {
      this.redrawHandles();
    }
  }

  /**
   * Rotates the vertex.
   */
  resizeVertex(me: InternalMouseEvent) {
    const ct = new Point(this.state.getCenterX(), this.state.getCenterY());
    const alpha = toRadians(this.state.style.rotation ?? 0);
    const point = new Point(me.getGraphX(), me.getGraphY());
    const tr = this.graph.view.translate;
    const { scale } = this.graph.view;
    let cos = Math.cos(-alpha);
    let sin = Math.sin(-alpha);

    let dx = point.x - this.startX;
    let dy = point.y - this.startY;

    // Rotates vector for mouse gesture
    const tx = cos * dx - sin * dy;
    const ty = sin * dx + cos * dy;

    dx = tx;
    dy = ty;

    const geo = this.state.cell.getGeometry();
    if (geo &amp;&amp; this.index !== null) {
      this.unscaledBounds = this.union(
        geo,
        dx / scale,
        dy / scale,
        this.index,
        this.graph.isGridEnabledEvent(me.getEvent()),
        1,
        new Point(0, 0),
        this.isConstrainedEvent(me),
        this.isCenteredEvent(this.state, me)
      );
    }

    // Keeps vertex within maximum graph or parent bounds
    if (geo &amp;&amp; !geo.relative) {
      let max = this.graph.getMaximumGraphBounds();

      // Handles child cells
      if (max != null &amp;&amp; this.parentState != null) {
        max = Rectangle.fromRectangle(max);

        max.x -= (this.parentState.x - tr.x * scale) / scale;
        max.y -= (this.parentState.y - tr.y * scale) / scale;
      }

      if (this.graph.isConstrainChild(this.state.cell)) {
        let tmp = this.graph.getCellContainmentArea(this.state.cell);

        if (tmp != null) {
          const overlap = this.graph.getOverlap(this.state.cell);

          if (overlap > 0) {
            tmp = Rectangle.fromRectangle(tmp);

            tmp.x -= tmp.width * overlap;
            tmp.y -= tmp.height * overlap;
            tmp.width += 2 * tmp.width * overlap;
            tmp.height += 2 * tmp.height * overlap;
          }

          if (!max) {
            max = tmp;
          } else {
            max = Rectangle.fromRectangle(max);
            max.intersect(tmp);
          }
        }
      }

      if (max &amp;&amp; this.unscaledBounds) {
        if (this.unscaledBounds.x &lt; max.x) {
          this.unscaledBounds.width -= max.x - this.unscaledBounds.x;
          this.unscaledBounds.x = max.x;
        }

        if (this.unscaledBounds.y &lt; max.y) {
          this.unscaledBounds.height -= max.y - this.unscaledBounds.y;
          this.unscaledBounds.y = max.y;
        }

        if (this.unscaledBounds.x + this.unscaledBounds.width > max.x + max.width) {
          this.unscaledBounds.width -=
            this.unscaledBounds.x + this.unscaledBounds.width - max.x - max.width;
        }

        if (this.unscaledBounds.y + this.unscaledBounds.height > max.y + max.height) {
          this.unscaledBounds.height -=
            this.unscaledBounds.y + this.unscaledBounds.height - max.y - max.height;
        }
      }
    }

    if (this.unscaledBounds) {
      const old = this.bounds;

      this.bounds = new Rectangle(
        (this.parentState ? this.parentState.x : tr.x * scale) +
          this.unscaledBounds.x * scale,
        (this.parentState ? this.parentState.y : tr.y * scale) +
          this.unscaledBounds.y * scale,
        this.unscaledBounds.width * scale,
        this.unscaledBounds.height * scale
      );

      if (geo &amp;&amp; geo.relative &amp;&amp; this.parentState) {
        this.bounds.x += this.state.x - this.parentState.x;
        this.bounds.y += this.state.y - this.parentState.y;
      }

      cos = Math.cos(alpha);
      sin = Math.sin(alpha);

      const c2 = new Point(this.bounds.getCenterX(), this.bounds.getCenterY());

      dx = c2.x - ct.x;
      dy = c2.y - ct.y;

      const dx2 = cos * dx - sin * dy;
      const dy2 = sin * dx + cos * dy;

      const dx3 = dx2 - dx;
      const dy3 = dy2 - dy;

      const dx4 = this.bounds.x - this.state.x;
      const dy4 = this.bounds.y - this.state.y;

      const dx5 = cos * dx4 - sin * dy4;
      const dy5 = sin * dx4 + cos * dy4;

      this.bounds.x += dx3;
      this.bounds.y += dy3;

      // Rounds unscaled bounds to int
      this.unscaledBounds.x = this.roundLength(this.unscaledBounds.x + dx3 / scale);
      this.unscaledBounds.y = this.roundLength(this.unscaledBounds.y + dy3 / scale);
      this.unscaledBounds.width = this.roundLength(this.unscaledBounds.width);
      this.unscaledBounds.height = this.roundLength(this.unscaledBounds.height);

      // Shifts the children according to parent offset
      if (!this.state.cell.isCollapsed() &amp;&amp; (dx3 !== 0 || dy3 !== 0)) {
        this.childOffsetX = this.state.x - this.bounds.x + dx5;
        this.childOffsetY = this.state.y - this.bounds.y + dy5;
      } else {
        this.childOffsetX = 0;
        this.childOffsetY = 0;
      }

      if (!old.equals(this.bounds)) {
        if (this.livePreviewActive) {
          this.updateLivePreview(me);
        }

        if (this.preview != null) {
          this.drawPreview();
        } else {
          this.updateParentHighlight();
        }
      }
    }
  }

  /**
   * Repaints the live preview.
   */
  updateLivePreview(me: InternalMouseEvent) {
    // TODO: Apply child offset to children in live preview
    const { scale } = this.graph.view;
    const tr = this.graph.view.translate;

    // Saves current state
    const tempState = this.state.clone();

    // Temporarily changes size and origin
    this.state.x = this.bounds.x;
    this.state.y = this.bounds.y;
    this.state.origin = new Point(
      this.state.x / scale - tr.x,
      this.state.y / scale - tr.y
    );
    this.state.width = this.bounds.width;
    this.state.height = this.bounds.height;

    // Redraws cell and handles
    let off = this.state.absoluteOffset;
    off = new Point(off.x, off.y);

    // Required to store and reset absolute offset for updating label position
    this.state.absoluteOffset.x = 0;
    this.state.absoluteOffset.y = 0;
    const geo = this.state.cell.getGeometry();

    if (geo != null) {
      const offset = geo.offset || this.EMPTY_POINT;

      if (offset != null &amp;&amp; !geo.relative) {
        this.state.absoluteOffset.x = this.state.view.scale * offset.x;
        this.state.absoluteOffset.y = this.state.view.scale * offset.y;
      }

      this.state.view.updateVertexLabelOffset(this.state);
    }

    // Draws the live preview
    (&lt;Graph>this.state.view.graph).cellRenderer.redraw(this.state, true);

    // Redraws connected edges TODO: Include child edges
    this.state.view.invalidate(this.state.cell);
    this.state.invalid = false;
    this.state.view.validate();
    this.redrawHandles();

    // Moves live preview to front
    if (this.movePreviewToFront) {
      this.moveToFront();
    }

    // Hides folding icon
    if (this.state.control != null &amp;&amp; this.state.control.node != null) {
      this.state.control.node.style.visibility = 'hidden';
    }

    // Restores current state
    this.state.setState(tempState);
  }

  /**
   * Handles the event by applying the changes to the geometry.
   */
  moveToFront() {
    if (
      (this.state.text &amp;&amp; this.state.text.node &amp;&amp; this.state.text.node.nextSibling) ||
      (this.state.shape &amp;&amp;
        this.state.shape.node &amp;&amp;
        this.state.shape.node.nextSibling &amp;&amp;
        (!this.state.text || this.state.shape.node.nextSibling !== this.state.text.node))
    ) {
      if (this.state.shape &amp;&amp; this.state.shape.node &amp;&amp; this.state.shape.node.parentNode) {
        this.state.shape.node.parentNode.appendChild(this.state.shape.node);
      }

      if (this.state.text &amp;&amp; this.state.text.node &amp;&amp; this.state.text.node.parentNode) {
        this.state.text.node.parentNode.appendChild(this.state.text.node);
      }
    }
  }

  /**
   * Handles the event by applying the changes to the geometry.
   */
  mouseUp(sender: EventSource, me: InternalMouseEvent) {
    if (this.index != null &amp;&amp; this.state != null) {
      const point = new Point(me.getGraphX(), me.getGraphY());
      const { index } = this;
      this.index = null;

      if (this.ghostPreview == null) {
        // Required to restore order in case of no change
        this.state.view.invalidate(this.state.cell, false, false);
        this.state.view.validate();
      }

      this.graph.getModel().beginUpdate();
      try {
        if (index &lt;= InternalEvent.CUSTOM_HANDLE) {
          if (this.customHandles != null) {
            // Creates style before changing cell state
            const style = (&lt;Graph>this.state.view.graph).getCellStyle(this.state.cell);

            this.customHandles[InternalEvent.CUSTOM_HANDLE - index].active = false;
            this.customHandles[InternalEvent.CUSTOM_HANDLE - index].execute(me);

            // Sets style and apply on shape to force repaint and
            // check if execute has removed custom handles
            if (
              this.customHandles != null &amp;&amp;
              this.customHandles[InternalEvent.CUSTOM_HANDLE - index] != null
            ) {
              this.state.style = style;
              this.customHandles[InternalEvent.CUSTOM_HANDLE - index].positionChanged();
            }
          }
        } else if (index === InternalEvent.ROTATION_HANDLE) {
          if (this.currentAlpha != null) {
            const delta = this.currentAlpha - (this.state.style.rotation ?? 0);

            if (delta !== 0) {
              this.rotateCell(this.state.cell, delta);
            }
          } else {
            this.rotateClick();
          }
        } else {
          const gridEnabled = this.graph.isGridEnabledEvent(me.getEvent());
          const alpha = toRadians(this.state.style.rotation ?? 0);
          const cos = Math.cos(-alpha);
          const sin = Math.sin(-alpha);

          let dx = point.x - this.startX;
          let dy = point.y - this.startY;

          // Rotates vector for mouse gesture
          const tx = cos * dx - sin * dy;
          const ty = sin * dx + cos * dy;

          dx = tx;
          dy = ty;

          const s = this.graph.view.scale;
          const recurse = this.isRecursiveResize(this.state, me);

          this.resizeCell(
            this.state.cell,
            this.roundLength(dx / s),
            this.roundLength(dy / s),
            index,
            gridEnabled,
            this.isConstrainedEvent(me),
            recurse
          );
        }
      } finally {
        this.graph.getModel().endUpdate();
      }

      me.consume();
      this.reset();
      this.redrawHandles();
    }
  }

  /**
   * Rotates the given cell to the given rotation.
   */
  isRecursiveResize(state: CellState, me: InternalMouseEvent) {
    return this.graph.isRecursiveResize(this.state);
  }

  /**
   * Hook for subclassers to implement a single click on the rotation handle.
   * This code is executed as part of the model transaction. This implementation
   * is empty.
   */
  rotateClick() {}

  /**
   * Rotates the given cell and its children by the given angle in degrees.
   *
   * @param cell &lt;Cell> to be rotated.
   * @param angle Angle in degrees.
   */
  rotateCell(cell: Cell, angle: number, parent?: Cell) {
    if (angle !== 0) {
      const model = this.graph.getModel();

      if (cell.isVertex() || cell.isEdge()) {
        if (!cell.isEdge()) {
          const style = this.graph.getCurrentCellStyle(cell);
          const total = (style.rotation || 0) + angle;
          this.graph.setCellStyles('rotation', total, new CellArray(cell));
        }

        let geo = cell.getGeometry();

        if (geo &amp;&amp; parent) {
          const pgeo = parent.getGeometry();

          if (pgeo != null &amp;&amp; !parent.isEdge()) {
            geo = geo.clone();
            geo.rotate(angle, new Point(pgeo.width / 2, pgeo.height / 2));
            model.setGeometry(cell, geo);
          }

          if ((cell.isVertex() &amp;&amp; !geo.relative) || cell.isEdge()) {
            // Recursive rotation
            const childCount = cell.getChildCount();

            for (let i = 0; i &lt; childCount; i += 1) {
              this.rotateCell(cell.getChildAt(i), angle, cell);
            }
          }
        }
      }
    }
  }

  /**
   * Resets the state of this handler.
   */
  reset() {
    if (this.index !== null &amp;&amp; this.sizers[this.index].node.style.display === 'none') {
      this.sizers[this.index].node.style.display = '';
    }

    this.index = null;

    // TODO: Reset and redraw cell states for live preview
    if (this.preview) {
      this.preview.destroy();
      this.preview = null;
    }

    if (this.ghostPreview) {
      this.ghostPreview.destroy();
      this.ghostPreview = null;
    }

    if (this.livePreviewActive) {
      for (let i = 0; i &lt; this.sizers.length; i += 1) {
        this.sizers[i].node.style.display = '';
      }

      // Shows folding icon
      if (this.state.control &amp;&amp; this.state.control.node) {
        this.state.control.node.style.visibility = '';
      }
    }

    for (let i = 0; i &lt; this.customHandles.length; i += 1) {
      if (this.customHandles[i].active) {
        this.customHandles[i].active = false;
        this.customHandles[i].reset();
      } else {
        this.customHandles[i].setVisible(true);
      }
    }

    // Checks if handler has been destroyed
    this.selectionBorder.node.style.display = 'inline';
    this.selectionBounds = this.getSelectionBounds(this.state);
    this.bounds = new Rectangle(
      this.selectionBounds.x,
      this.selectionBounds.y,
      this.selectionBounds.width,
      this.selectionBounds.height
    );
    this.drawPreview();

    this.removeHint();
    this.redrawHandles();
    this.edgeHandlers = [];
    this.handlesVisible = true;
    this.unscaledBounds = null;
  }

  /**
   * Uses the given vector to change the bounds of the given cell
   * in the graph using &lt;mxGraph.resizeCell>.
   */
  resizeCell(
    cell: Cell,
    dx: number,
    dy: number,
    index: number,
    gridEnabled: boolean,
    constrained: boolean,
    recurse: boolean
  ) {
    let geo = cell.getGeometry();

    if (geo) {
      if (
        index === InternalEvent.LABEL_HANDLE &amp;&amp;
        this.labelShape &amp;&amp;
        this.labelShape.bounds
      ) {
        const alpha = -toRadians(this.state.style.rotation ?? 0);
        const cos = Math.cos(alpha);
        const sin = Math.sin(alpha);
        const { scale } = this.graph.view;
        const pt = getRotatedPoint(
          new Point(
            Math.round((this.labelShape.bounds.getCenterX() - this.startX) / scale),
            Math.round((this.labelShape.bounds.getCenterY() - this.startY) / scale)
          ),
          cos,
          sin
        );

        geo = geo.clone();

        if (geo.offset == null) {
          geo.offset = pt;
        } else {
          geo.offset.x += pt.x;
          geo.offset.y += pt.y;
        }

        this.graph.model.setGeometry(cell, geo);
      } else if (this.unscaledBounds) {
        const { scale } = this.graph.view;

        if (this.childOffsetX !== 0 || this.childOffsetY !== 0) {
          this.moveChildren(
            cell,
            Math.round(this.childOffsetX / scale),
            Math.round(this.childOffsetY / scale)
          );
        }

        this.graph.resizeCell(cell, this.unscaledBounds, recurse);
      }
    }
  }

  /**
   * Moves the children of the given cell by the given vector.
   */
  moveChildren(cell: Cell, dx: number, dy: number) {
    const model = this.graph.getModel();
    const childCount = cell.getChildCount();

    for (let i = 0; i &lt; childCount; i += 1) {
      const child = cell.getChildAt(i);
      let geo = child.getGeometry();

      if (geo != null) {
        geo = geo.clone();
        geo.translate(dx, dy);
        model.setGeometry(child, geo);
      }
    }
  }

  /**
   * Returns the union of the given bounds and location for the specified
   * handle index.
   *
   * To override this to limit the size of vertex via a minWidth/-Height style,
   * the following code can be used.
   *
   * ```javascript
   * let vertexHandlerUnion = union;
   * union = (bounds, dx, dy, index, gridEnabled, scale, tr, constrained)=>
   * {
   *   let result = vertexHandlerUnion.apply(this, arguments);
   *
   *   result.width = Math.max(result.width, mxUtils.getNumber(this.state.style, 'minWidth', 0));
   *   result.height = Math.max(result.height, mxUtils.getNumber(this.state.style, 'minHeight', 0));
   *
   *   return result;
   * };
   * ```
   *
   * The minWidth/-Height style can then be used as follows:
   *
   * ```javascript
   * graph.insertVertex(parent, null, 'Hello,', 20, 20, 80, 30, 'minWidth=100;minHeight=100;');
   * ```
   *
   * To override this to update the height for a wrapped text if the width of a vertex is
   * changed, the following can be used.
   *
   * ```javascript
   * let mxVertexHandlerUnion = union;
   * union = (bounds, dx, dy, index, gridEnabled, scale, tr, constrained)=>
   * {
   *   let result = mxVertexHandlerUnion.apply(this, arguments);
   *   let s = this.state;
   *
   *   if (this.graph.isHtmlLabel(s.cell) &amp;&amp; (index == 3 || index == 4) &amp;&amp;
   *       s.text != null &amp;&amp; s.style.whiteSpace == 'wrap')
   *   {
   *     let label = this.graph.getLabel(s.cell);
   *     let fontSize = mxUtils.getNumber(s.style, 'fontSize', mxConstants.DEFAULT_FONTSIZE);
   *     let ww = result.width / s.view.scale - s.text.spacingRight - s.text.spacingLeft
   *
   *     result.height = mxUtils.getSizeForString(label, fontSize, s.style.fontFamily, ww).height;
   *   }
   *
   *   return result;
   * };
   * ```
   */
  union(
    bounds: Rectangle,
    dx: number,
    dy: number,
    index: number,
    gridEnabled: boolean,
    scale: number,
    tr: Point,
    constrained: boolean,
    centered: boolean
  ) {
    gridEnabled = gridEnabled &amp;&amp; this.graph.isGridEnabled();

    if (this.singleSizer) {
      let x = bounds.x + bounds.width + dx;
      let y = bounds.y + bounds.height + dy;

      if (gridEnabled) {
        x = this.graph.snap(x / scale) * scale;
        y = this.graph.snap(y / scale) * scale;
      }

      const rect = new Rectangle(bounds.x, bounds.y, 0, 0);
      rect.add(new Rectangle(x, y, 0, 0));

      return rect;
    }
    const w0 = bounds.width;
    const h0 = bounds.height;
    let left = bounds.x - tr.x * scale;
    let right = left + w0;
    let top = bounds.y - tr.y * scale;
    let bottom = top + h0;

    const cx = left + w0 / 2;
    const cy = top + h0 / 2;

    if (index > 4 /* Bottom Row */) {
      bottom += dy;

      if (gridEnabled) {
        bottom = this.graph.snap(bottom / scale) * scale;
      } else {
        bottom = Math.round(bottom / scale) * scale;
      }
    } else if (index &lt; 3 /* Top Row */) {
      top += dy;

      if (gridEnabled) {
        top = this.graph.snap(top / scale) * scale;
      } else {
        top = Math.round(top / scale) * scale;
      }
    }

    if (index === 0 || index === 3 || index === 5 /* Left */) {
      left += dx;

      if (gridEnabled) {
        left = this.graph.snap(left / scale) * scale;
      } else {
        left = Math.round(left / scale) * scale;
      }
    } else if (index === 2 || index === 4 || index === 7 /* Right */) {
      right += dx;

      if (gridEnabled) {
        right = this.graph.snap(right / scale) * scale;
      } else {
        right = Math.round(right / scale) * scale;
      }
    }

    let width = right - left;
    let height = bottom - top;

    if (constrained) {
      const geo = this.state.cell.getGeometry();

      if (geo != null) {
        const aspect = geo.width / geo.height;

        if (index === 1 || index === 2 || index === 7 || index === 6) {
          width = height * aspect;
        } else {
          height = width / aspect;
        }

        if (index === 0) {
          left = right - width;
          top = bottom - height;
        }
      }
    }

    if (centered) {
      width += width - w0;
      height += height - h0;

      const cdx = cx - (left + width / 2);
      const cdy = cy - (top + height / 2);

      left += cdx;
      top += cdy;
      right += cdx;
      bottom += cdy;
    }

    // Flips over left side
    if (width &lt; 0) {
      left += width;
      width = Math.abs(width);
    }

    // Flips over top side
    if (height &lt; 0) {
      top += height;
      height = Math.abs(height);
    }

    const result = new Rectangle(left + tr.x * scale, top + tr.y * scale, width, height);

    if (this.minBounds != null) {
      result.width = Math.max(
        result.width,
        this.minBounds.x * scale +
          this.minBounds.width * scale +
          Math.max(0, this.x0 * scale - result.x)
      );
      result.height = Math.max(
        result.height,
        this.minBounds.y * scale +
          this.minBounds.height * scale +
          Math.max(0, this.y0 * scale - result.y)
      );
    }

    return result;
  }

  /**
   * Redraws the handles and the preview.
   */
  redraw(ignoreHandles?: boolean) {
    this.selectionBounds = this.getSelectionBounds(this.state);
    this.bounds = new Rectangle(
      this.selectionBounds.x,
      this.selectionBounds.y,
      this.selectionBounds.width,
      this.selectionBounds.height
    );
    this.drawPreview();

    if (!ignoreHandles) {
      this.redrawHandles();
    }
  }

  /**
   * Returns the padding to be used for drawing handles for the current &lt;bounds>.
   */
  getHandlePadding() {
    // KNOWN: Tolerance depends on event type (eg. 0 for mouse events)
    const result = new Point(0, 0);
    let tol = this.tolerance;

    if (
      this.sizers.length > 0 &amp;&amp;
      this.sizers[0].bounds &amp;&amp;
      (this.bounds.width &lt; 2 * this.sizers[0].bounds.width + 2 * tol ||
        this.bounds.height &lt; 2 * this.sizers[0].bounds.height + 2 * tol)
    ) {
      tol /= 2;

      result.x = this.sizers[0].bounds.width + tol;
      result.y = this.sizers[0].bounds.height + tol;
    }

    return result;
  }

  /**
   * Returns the bounds used to paint the resize handles.
   */
  getSizerBounds() {
    return this.bounds;
  }

  /**
   * Redraws the handles. To hide certain handles the following code can be used.
   *
   * ```javascript
   * redrawHandles()
   * {
   *   mxVertexHandlerRedrawHandles.apply(this, arguments);
   *
   *   if (this.sizers != null &amp;&amp; this.sizers.length > 7)
   *   {
   *     this.sizers[1].node.style.display = 'none';
   *     this.sizers[6].node.style.display = 'none';
   *   }
   * };
   * ```
   */
  redrawHandles() {
    let s = this.getSizerBounds();
    const tol = this.tolerance;
    this.horizontalOffset = 0;
    this.verticalOffset = 0;

    for (let i = 0; i &lt; this.customHandles.length; i += 1) {
      const shape = this.customHandles[i].shape;

      if (shape) {
        const temp = shape.node.style.display;
        this.customHandles[i].redraw();
        shape.node.style.display = temp;

        // Hides custom handles during text editing
        shape.node.style.visibility =
          this.handlesVisible &amp;&amp; this.isCustomHandleVisible(this.customHandles[i])
            ? ''
            : 'hidden';
      }
    }

    if (this.sizers.length > 0 &amp;&amp; this.sizers[0]) {
      if (this.index === null &amp;&amp; this.manageSizers &amp;&amp; this.sizers.length >= 8) {
        // KNOWN: Tolerance depends on event type (eg. 0 for mouse events)
        const padding = this.getHandlePadding();
        this.horizontalOffset = padding.x;
        this.verticalOffset = padding.y;

        if (this.horizontalOffset !== 0 || this.verticalOffset !== 0) {
          s = new Rectangle(s.x, s.y, s.width, s.height);

          s.x -= this.horizontalOffset / 2;
          s.width += this.horizontalOffset;
          s.y -= this.verticalOffset / 2;
          s.height += this.verticalOffset;
        }

        if (this.sizers.length >= 8) {
          if (
            this.sizers[0].bounds &amp;&amp;
            (s.width &lt; 2 * this.sizers[0].bounds.width + 2 * tol ||
              s.height &lt; 2 * this.sizers[0].bounds.height + 2 * tol)
          ) {
            this.sizers[0].node.style.display = 'none';
            this.sizers[2].node.style.display = 'none';
            this.sizers[5].node.style.display = 'none';
            this.sizers[7].node.style.display = 'none';
          } else if (this.handlesVisible) {
            this.sizers[0].node.style.display = '';
            this.sizers[2].node.style.display = '';
            this.sizers[5].node.style.display = '';
            this.sizers[7].node.style.display = '';
          }
        }
      }

      const r = s.x + s.width;
      const b = s.y + s.height;

      if (this.singleSizer) {
        this.moveSizerTo(this.sizers[0], r, b);
      } else {
        const cx = s.x + s.width / 2;
        const cy = s.y + s.height / 2;

        if (this.sizers.length >= 8) {
          const crs = [
            'nw-resize',
            'n-resize',
            'ne-resize',
            'e-resize',
            'se-resize',
            's-resize',
            'sw-resize',
            'w-resize',
          ];

          const alpha = toRadians(this.state.style.rotation ?? 0);
          const cos = Math.cos(alpha);
          const sin = Math.sin(alpha);
          const da = Math.round((alpha * 4) / Math.PI);

          const ct = new Point(s.getCenterX(), s.getCenterY());
          let pt = getRotatedPoint(new Point(s.x, s.y), cos, sin, ct);
          this.moveSizerTo(this.sizers[0], pt.x, pt.y);
          this.sizers[0].setCursor(crs[mod(0 + da, crs.length)]);

          pt.x = cx;
          pt.y = s.y;
          pt = getRotatedPoint(pt, cos, sin, ct);
          this.moveSizerTo(this.sizers[1], pt.x, pt.y);
          this.sizers[1].setCursor(crs[mod(1 + da, crs.length)]);

          pt.x = r;
          pt.y = s.y;
          pt = getRotatedPoint(pt, cos, sin, ct);
          this.moveSizerTo(this.sizers[2], pt.x, pt.y);
          this.sizers[2].setCursor(crs[mod(2 + da, crs.length)]);

          pt.x = s.x;
          pt.y = cy;
          pt = getRotatedPoint(pt, cos, sin, ct);
          this.moveSizerTo(this.sizers[3], pt.x, pt.y);
          this.sizers[3].setCursor(crs[mod(7 + da, crs.length)]);

          pt.x = r;
          pt.y = cy;
          pt = getRotatedPoint(pt, cos, sin, ct);
          this.moveSizerTo(this.sizers[4], pt.x, pt.y);
          this.sizers[4].setCursor(crs[mod(3 + da, crs.length)]);

          pt.x = s.x;
          pt.y = b;
          pt = getRotatedPoint(pt, cos, sin, ct);
          this.moveSizerTo(this.sizers[5], pt.x, pt.y);
          this.sizers[5].setCursor(crs[mod(6 + da, crs.length)]);

          pt.x = cx;
          pt.y = b;
          pt = getRotatedPoint(pt, cos, sin, ct);
          this.moveSizerTo(this.sizers[6], pt.x, pt.y);
          this.sizers[6].setCursor(crs[mod(5 + da, crs.length)]);

          pt.x = r;
          pt.y = b;
          pt = getRotatedPoint(pt, cos, sin, ct);
          this.moveSizerTo(this.sizers[7], pt.x, pt.y);
          this.sizers[7].setCursor(crs[mod(4 + da, crs.length)]);

          pt.x = cx + this.state.absoluteOffset.x;
          pt.y = cy + this.state.absoluteOffset.y;
          pt = getRotatedPoint(pt, cos, sin, ct);
          this.moveSizerTo(this.sizers[8], pt.x, pt.y);
        } else if (this.state.width >= 2 &amp;&amp; this.state.height >= 2) {
          this.moveSizerTo(
            this.sizers[0],
            cx + this.state.absoluteOffset.x,
            cy + this.state.absoluteOffset.y
          );
        } else {
          this.moveSizerTo(this.sizers[0], this.state.x, this.state.y);
        }
      }
    }

    if (this.rotationShape) {
      const alpha = toRadians(this.currentAlpha);
      const cos = Math.cos(alpha);
      const sin = Math.sin(alpha);

      const ct = new Point(this.state.getCenterX(), this.state.getCenterY());
      const pt = getRotatedPoint(this.getRotationHandlePosition(), cos, sin, ct);

      if (this.rotationShape.node != null) {
        this.moveSizerTo(this.rotationShape, pt.x, pt.y);

        // Hides rotation handle during text editing
        this.rotationShape.node.style.visibility =
          (&lt;Graph>this.state.view.graph).isEditing() || !this.handlesVisible ? 'hidden' : '';
      }
    }

    if (this.selectionBorder != null) {
      this.selectionBorder.rotation = this.state.style.rotation ?? 0;
    }

    if (this.edgeHandlers != null) {
      for (let i = 0; i &lt; this.edgeHandlers.length; i += 1) {
        this.edgeHandlers[i].redraw();
      }
    }
  }

  /**
   * Returns true if the given custom handle is visible.
   */
  isCustomHandleVisible(handle: CellHandle) {
    return !this.graph.isEditing() &amp;&amp; (&lt;Graph>this.state.view.graph).getSelectionCount() === 1;
  }

  /**
   * Returns an &lt;mxPoint> that defines the rotation handle position.
   */
  getRotationHandlePosition() {
    return new Point(
      this.bounds.x + this.bounds.width / 2,
      this.bounds.y + this.rotationHandleVSpacing
    );
  }

  /**
   * Returns true if the parent highlight should be visible. This implementation
   * always returns true.
   */
  isParentHighlightVisible() {
    const parent = this.state.cell.getParent();
    return parent ? !this.graph.isCellSelected(parent) : false;
  }

  /**
   * Updates the highlight of the parent if &lt;parentHighlightEnabled> is true.
   */
  updateParentHighlight() {
    if (!this.isDestroyed()) {
      const visible = this.isParentHighlightVisible();
      const parent = this.state.cell.getParent();
      const pstate = parent ? this.graph.view.getState(parent) : null;

      if (this.parentHighlight) {
        if (parent &amp;&amp; parent.isVertex() &amp;&amp; visible) {
          const b = this.parentHighlight.bounds;

          if (
            pstate &amp;&amp;
            b &amp;&amp;
            (b.x !== pstate.x ||
              b.y !== pstate.y ||
              b.width !== pstate.width ||
              b.height !== pstate.height)
          ) {
            this.parentHighlight.bounds = Rectangle.fromRectangle(pstate);
            this.parentHighlight.redraw();
          }
        } else {
          if (pstate != null &amp;&amp; pstate.parentHighlight === this.parentHighlight) {
            pstate.parentHighlight = null;
          }

          this.parentHighlight.destroy();
          this.parentHighlight = null;
        }
      } else if (this.parentHighlightEnabled &amp;&amp; visible) {
        if (
          parent &amp;&amp;
          parent.isVertex() &amp;&amp;
          pstate != null &amp;&amp;
          pstate.parentHighlight == null
        ) {
          this.parentHighlight = this.createParentHighlightShape(pstate);
          // VML dialect required here for event transparency in IE
          this.parentHighlight.dialect = DIALECT.SVG;
          this.parentHighlight.pointerEvents = false;
          this.parentHighlight.rotation = pstate.style.rotation ?? 0;
          this.parentHighlight.init(this.graph.getView().getOverlayPane());
          this.parentHighlight.redraw();

          // Shows highlight once per parent
          pstate.parentHighlight = this.parentHighlight;
        }
      }
    }
  }

  /**
   * Redraws the preview.
   */
  // drawPreview(): void;
  drawPreview() {
    if (this.preview != null) {
      this.preview.bounds = this.bounds;

      if (this.preview.node.parentNode === this.graph.container) {
        this.preview.bounds.width = Math.max(0, this.preview.bounds.width - 1);
        this.preview.bounds.height = Math.max(0, this.preview.bounds.height - 1);
      }

      this.preview.rotation = this.state.style.rotation ?? 0;
      this.preview.redraw();
    }

    this.selectionBorder.bounds = this.getSelectionBorderBounds();
    this.selectionBorder.redraw();
    this.updateParentHighlight();
  }

  /**
   * Returns the bounds for the selection border.
   */
  getSelectionBorderBounds() {
    return this.bounds;
  }

  /**
   * Returns true if this handler was destroyed or not initialized.
   */
  isDestroyed() {
    return this.selectionBorder == null;
  }

  /**
   * Destroys the handler and all its resources and DOM nodes.
   */
  onDestroy() {
    (&lt;Graph>this.state.view.graph).removeListener(this.escapeHandler);
    this.escapeHandler = () => {};

    if (this.preview) {
      this.preview.destroy();
      this.preview = null;
    }

    if (this.parentHighlight) {
      const parent = this.state.cell.getParent();
      const pstate = parent ? this.graph.view.getState(parent) : null;

      if (pstate &amp;&amp; pstate.parentHighlight === this.parentHighlight) {
        pstate.parentHighlight = null;
      }

      this.parentHighlight.destroy();
      this.parentHighlight = null;
    }

    if (this.ghostPreview) {
      this.ghostPreview.destroy();
      this.ghostPreview = null;
    }

    if (this.selectionBorder) {
      this.selectionBorder.destroy();
    }

    this.labelShape = null;
    this.removeHint();

    for (let i = 0; i &lt; this.sizers.length; i += 1) {
      this.sizers[i].destroy();
    }

    this.sizers = [];

    for (let i = 0; i &lt; this.customHandles.length; i += 1) {
      this.customHandles[i].destroy();
    }

    this.customHandles = [];
  }
}

export default VertexHandler;
</code></pre>
        </article>
    </section>




            </div>
            
            <footer class="footer">
                <div class="content has-text-centered">
                    <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a></p>
                    <p class="sidebar-created-by">
                        <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by 
                        <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers - JavaScript Development Agency</a>
                    </p>
                </div>
            </footer>
            
        </div>
        <div id="side-nav" class="side-nav">
        </div>
    </div>
<script src="scripts/app.min.js"></script>
<script>PR.prettyPrint();</script>
<script src="scripts/linenumber.js"> </script>

</body>
</html>
