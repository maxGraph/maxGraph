<!-- ================================================================================= -->
<!-- in 1.1 this doesn't apply in maxGraph -->
<!-- all mxgraph components, including server components -->
<!-- ================================================================================= -->
<p><img src="images/mx_man_architecture.png" name="mxgraph_architecture" />
<br/>
<em>The mxGraph components and their relationships</em></p>


<!-- ================================================================================= -->
<!-- in 2 -->
<!-- ================================================================================= -->

<!-- in 2.1.2 this doesn't apply in maxGraph -->
<h3><a id="project_structure"></a>Project structure and build
options</h3>

<p>Once unzipped you will be presented with a number of files and
directories in the installation root.</p>

<TABLE WIDTH=642 BORDER=1 BORDERCOLOR="#000000" CELLPADDING=4
	CELLSPACING=0>
	<COL WIDTH=165>
	<COL WIDTH=459>
	<THEAD>
		<TR VALIGN=TOP>
			<TD WIDTH=165>
			<p>/doc</p>
			</TD>
			<TD WIDTH=459>
			<p>Documentation root, includes this user manual</p>
			</TD>
		</TR>
	</THEAD>
	<TBODY>
		<TR VALIGN=TOP>
			<TD WIDTH=165>
			<p>/dotnet</p>
			</TD>
			<TD WIDTH=459>
			<p>.NET server-side classes</p>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=165>
			<p>/java</p>
			</TD>
			<TD WIDTH=459>
			<p>Java server-side classes</p>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=165>
			<p>/javascript</p>
			</TD>
			<TD WIDTH=459>
			<p>JavaScript client functionality.</p>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=165>
			<p>/javascript/examples</p>
			</TD>
			<TD WIDTH=459>
			<p>HTML examples demonstrating the use of mxGraph</p>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=165>
			<p>ChangeLog</p>
			</TD>
			<TD WIDTH=459>
			<p>Details of the changes between releases</p>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=165>
			<p>index.html</p>
			</TD>
			<TD WIDTH=459>
			<p>Basic introduction to the library</p>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=165>
			<p>license.txt</p>
			</TD>
			<TD WIDTH=459>
			<p>The licensing terms under which you must use the library</p>
			</TD>
		</TR>
	</TBODY>
</TABLE>

<p><em>Table: Project Directory Structure</em></p>
<br/>


<h3><a id="npm"></a>npm</h3>

<p>mxGraph is also available via the npm package manager. To use mxGraph as
	a depedency, use <code>npm install</code>:</p>

<pre>npm install mxgraph --save</pre>

<p>The module can be loaded using <code>require()</code>. This returns a
	factory function that accepts an object of options. Options such as
	<code>mxBasePath</code> must be provided to the factory function, rather
	than specified as global variables.</p>

<pre>let mxgraph = require("mxgraph")({
  mxImageBasePath: "./src/images",
  mxBasePath: "./src"
})</pre>

<p>The factory function returns a 'namespace object' that provides access to
	all objects of the mxGraph package. For example, the <code>mxEvent</code>
	object is available at <code>mxgraph.mxEvent</code>.</p>

<pre>let mxEvent = mxgraph.mxEvent;
mxEvent.disableContextMenu(container);</pre>

<h2><a id="web_applications"></a>JavaScript and Web Applications</h2>

<p>Web applications, specifically the use of JavaScript to attempt
to emulate desktop application-like behaviour in web browsers, is still
a relatively new field of software engineering. There are three main
issues with JavaScript that are perceived to be a barrier to producing
high quality applications, performance, lack of native functionality
available in desktop applications and inconsistent APIs between
browsers.</p>

<p>There has been considerable effort toward developing framework
libraries to solve two of the problems, the functionality and API
issues. The requirements of many of these libraries is driven by both
improving web site design and usability, as well as to assist production
of what we generally refer to as application features (menus, windows,
dialogs, persistence, event handling, etc). They also provide certain
base functionalities missing in JavaScript that desktop application
developers take for granted, such as basic maths and collections
functionality.</p>

<p>Many of these JavaScript frameworks have IDE support for
development nowadays and all of the major browsers now contain
JavaScript debuggers, either natively or as a plug-in. There is no
compilation phase with JavaScript (it is an interpreted language) so
basic typographical errors are often only caught at runtime, unless you
obtain a syntax checking tool in your IDE. So although there is not one
complete package for your JavaScript development needs, there are a
number of vendors providing the individual components you need to
produce JavaScript applications effectively.</p>

<h3><a id="js_frameworks"></a>Third-Party JavaScript Frameworks</h3>

<h4><a id="native_js_frameworks"></a>Native JavaScript Frameworks
and Libraries</h4>

<p>Rather than list and compare every JavaScript framework, please
see the wikipedia entries for <a
	href="http://en.wikipedia.org/wiki/List_of_JavaScript_libraries#JavaScript">web
application frameworks</a> and the <a
	href="http://en.wikipedia.org/wiki/Comparison_of_JavaScript_frameworks">comparison
of JavaScript</a>. The comparison should not be considered authoritative,
more so it illustrates the types of features provided, such as event
handling, animation, widgets, AJAX request support etc.</p>

<p>Be aware that many frameworks add implicit behaviours to make
JavaScript appear more like an OO language and to increase the base
functionality of the language. During the writing of the layout portion
of mxGraph, it was found that this implicit behaviour broke an example
in a very hard to debug manner. Be aware that this may cause
problems and if you select a framework ensure you understand which
implicit behaviours it introduces.</p>

<p>When selecting a framework and/or libraries think about which
frameworks tie you into certain functional behaviour and look for
libraries that provide features such as animation as distinct,
independent blocks, that you can use without being tied into the overall
design.</p>

<h4><a id="integration_js_frameworks"></a>Integration of mxGraph
and JavaScript frameworks</h4>

<p>This area is often misunderstood, put simply, there is no <em>integration</em>
required. Web applications generally comprise one or more <a
	href="http://en.wikipedia.org/wiki/Span_and_div"><em>div</em></a>
elements into which the HTML wrapping the JavaScript of the application
is placed. If you create a div as a container for an mxGraph, that area
is a stand-alone display for the mxGraph application. It can communicate
itself with any back-end server, but there is no interdependence between
that div and the rest of the page, other than the area each take up.
This includes event handling, mxGraph can handle the events for its
container, even if the rest of the web page used a completely different
event model. As long as neither mxGraph nor the other libraries and
frameworks on the page introduce implicit behaviours that break one part
of the page, the issue of client integration is not something that needs
analysis.</p>

<p>Integration of the mxGraph back-end functionality, that which
sits at the server-side is the subject of a later chapter.</p>

<h4><a id="extending_mxgraph"></a>Extending mxGraph in JavaScript</h4>

<p>In JavaScript, there are various ways of mapping the Object
Oriented paradigm to language constructs. mxGraph uses a particular
scheme throughout the project, with the following implicit rules:</p>

<ul>
	<li>Do not change the built-in prototypes</li>
	<li>Do not try to limit the power of the JavaScript language.</li>

</ul>

<p>There are two types of &ldquo;classes&rdquo; in mxGraph; <EM>classes</em>
and <EM>singletons</em> (where only one instance of the class exists).
Singletons are mapped to global objects where the variable name is the
same as the class name. For example, mxConstants is an object with all
the constants defined as object fields. Normal classes are mapped to a
constructor function and a prototype which defines the instance fields
and methods. For example, mxEditor is a function and mxEditor.prototype
is the prototype for the object that the mxEditor function creates. The
<em>mx</em> prefix is a convention that is used for all classes in the
mxGraph package to avoid conflicts with other objects in the global
namespace.</p>

<p>For subclassing, the superclass must provide a constructor that
is either parameterless or handles an invocation with no arguments.
Furthermore, the special constructor field must be redefined after
extending the prototype. For example, the superclass of mxEditor is
mxEventSource. This is represented in JavaScript by first
&ldquo;inheriting&rdquo; all fields and methods from the superclass by
assigning the prototype to an instance of the superclass, eg.</p>
<pre>mxEditor.prototype = new mxEventSource()</pre>
<p>and redefining the constructor field using:</p>

<pre>mxEditor.prototype.constructor = mxEditor</pre>

<p>The latter rule is applied so that the type of an object can be
retrieved via the name of it&rsquo;s constructor using <EM>mxUtils.getFunctionName(obj.constructor)</em>.</p>

<h5><a id="constructor"></a>Constructor</h5>

<p>For subclassing in mxGraph, the same mechanism should be applied.
For example, for subclassing the mxGraph class, first a constructor must
be defined for the new class. The constructor calls the super
constructor with any arguments that it may have using the <em>call</em>
function on the mxGraph function object, passing along explicitly each
argument:</p>
<pre>
function MyGraph(container)
{
   mxGraph.call(this, container);
}
</pre>

<p>The prototype of MyGraph inherits from mxGraph as follows. As
usual, the constructor is redefined after extending the superclass:</p>

<pre>MyGraph.prototype = new mxGraph();
MyGraph.prototype.constructor = MyGraph;</pre>

<p>You may want to define the codec associated for the class after
the above code (see I/O section of manual). This code will be executed
at class loading time and makes sure the same codec is used to encode
instances of mxGraph and MyGraph.</p>

<pre>
let codec = mxCodecRegistry.getCodec(mxGraph);
codec.template = new MyGraph();
mxCodecRegistry.register(codec);
</pre>

<h5><a id="functions"></a>Functions</h5>

<p>In the prototype for MyGraph, functions of mxGraph can be
extended as follows.</p>
<pre>
MyGraph.prototype.isSelectable = function(cell)
{
   let selectable = mxGraph.prototype.isSelectable.apply(this, arguments);
   let geo = this.model.getGeometry(cell);
   return selectable &amp;&amp;(geo == null || !geo.relative);
}
</pre>

<p>The supercall in the first line is optional. It is done using the
<em>apply</em> function on the <em>isSelectable</em> function object of
the mxGraph prototype, using the special <em>this</em> and <em>arguments</em>
variables as parameters. Calls to the superclass function are only
possible if the function is not replaced in the superclass as follows,
which is another way of &ldquo;subclassing&rdquo; in JavaScript.</p>

<pre>
mxGraph.prototype.isSelectable = function(cell)
{
   let geo = this.model.getGeometry(cell);
   return selectable &amp;&amp; (geo == null || !geo.relative);
}
</pre>

<p>The above scheme is useful if a function definition needs to be
replaced completely.</p>
<p>In order to add new functions and fields to the subclass, the
following code is used. The example below adds a new function to return
the XML representation of the graph model:</p>
<pre>
MyGraph.prototype.getXml = function()
{
   let enc = new mxCodec();
   return enc.encode(this.getModel());
}
</pre>

<h5><a id="fields"></a>Fields</h5>
<p>Likewise, a new field is declared and defined as follows:</p>
<pre>
MyGraph.prototype.myField = &lsquo;Hello, World!&rsquo;;
</pre>
<p>Note that the value assigned to myField is created only once,
that is, all instances of MyGraph share the same value. If you require
instance-specific values, then the field must be defined in the
constructor instead. For example:</p>
<pre>
function MyGraph(container)
{
   mxGraph.call(this, container);
   this.myField = [];
}
</pre>
<p>Finally, a new instance of MyGraph is created using the following
code, where container is a DOM node that acts as a container for the
graph view:</p>
<pre>
let graph = new MyGraph(container);
</pre>
<br/>

<h3><a id="general_javascript"></a>General JavaScript Development</h3>

<h4><a id="javascript_obfuscation"></a>JavaScript Obfuscation</h4>
<p>By default, when you deliver JavaScript to a browser client, you
deliver the entire source to that JavaScript. That JavaScript is then
interpreted and run on the browser. It is not possible to encrypt the
JavaScript to any extent on the client at the point it is run, since the
JavaScript source must be understood by the JavaScript interpretor and
interpreted languages do not have a binary intermediate form.</p>

<p>It would be possible to encrypt the JavaScript in transmission
and have it decrypted and run on the client, but the client would still
be able to access the source after decryption.</p>

<p>We do not obfuscate because the method names form a public API
and I/O would need to understand the obfuscation at both communication
ends.</p>

<h4><a id="namespaces"></a>Namespaces</h4>
<p>The concept of namespaces does not exist in standised JavaScript, so take
great care when creating new class names. In mxGraph, all of the classes
begin with the prefix &ldquo;mx-&rdquo;, to avoid clashes or overriding
prototypes unintentionally.

<br/>
<h2><a id="hello_world"></a>Hello World!</h2>
<p>Hello World in mxGraph consists of a simple client-side example
that displays two connected vertices with the labels &ldquo;Hello&rdquo;
and &ldquo;World!&rdquo;. The example demonstrates the following things:
</p>

<ul>
	<li><strong>Creating an HTML page that links the mxGraph
	client JavaScript,</strong></li>
	<li><strong>Creating a container to place the mxGraph
	into,</strong></li>
	<li><strong>Adds the required cells to that graph.</strong></li>
</ul>

<p>The source code for the example, helloworld.html, can be found
below and in the examples directory of both the evaluation and full
versions of mxGraph. The HTML source contains two main sections, the
head and the body. These contain the following main elements that you
can consider a template for building a basic mxGraph application:</p>

<ul>
	<li><strong>mxBasePath</strong>: This is a JavaScript variable
	that defines the directory within which the css, images, resources and js
	directories are expected to be found. It is JavaScript code and needs
	to be placed with in a <em>script</em> tag. This must come before the
	line loading mxClient.js and should not have a trailing slash.</li>

	<li><strong>mxClient.js</strong>: This is the path to mxGraph
	library. If the HTML file is executed locally, the path might be local
	to the computer or a public Internet path. If the html page were
	downloaded from a web server, the path would generally be a public
	Internet path.</li>

	<li><strong>Creation of the container</strong>: At the bottom of
	the code, in the body element, the function that is called on loading
	the web page is defined (the value of onload). It passes in a div
	container as a parameter, that is defined underneath. This div is the
	container the mxGraph component will be placed within. In this example
	a grid background is applied, as commonly used in diagramming
	applications. No other part of the graph visuals are described at
	container creation, other than the background and the container width
	and height.

	<p>Note that the overflow:hidden style should always be used if you
	want no scrollbars to appear.</p>

	</li>

	<li><strong>The entry function</strong>: The main code of the file
	is the entry method executed on page load in this case. This is
	JavaScript code and must be within a JavaScript <em>script</em>
	element. The first lines of any mxGraph application should be to check
	the browser is supported and exit appropriately if not. If the browser
	is supported, a mxGraph is created within the div container and three
	cells are added to the graph between the begin/end update calls.</li>
</ul>
<br/>
<p><img src="images/mx_man_hello_world.png" name="ill_hello_world" />
<br/>
<em>The mxGraph HelloWorld example</em></p>
<br/>

<pre>
&lt;html&gt;
&lt;head&gt;
   &lt;title&gt;Hello, World! example for mxGraph&lt;/title&gt;

   &lt;!-- Sets the <U>basepath</U> for the library if not in same directory --&gt;
   &lt;script type=<em>&quot;text/javascript&quot;</em>&gt;
      mxBasePath = '../src';
   &lt;/script&gt;

   &lt;!-- Loads and <U>initializes</U> the library --&gt;
   &lt;script type=<em>&quot;text/javascript&quot;</em> src=<em>&quot;../src/js/mxClient.js&quot;</em>&gt;&lt;/script&gt;

   &lt;!-- Example code --&gt;
   &lt;script type=<em>&quot;text/javascript&quot;</em>&gt;
      // Program starts here. Creates a sample graph in the
      // DOM node with the specified ID. This function is invoked
      // from the onLoad event handler of the document (see below).
      function main(container)
      {
         // Checks if the browser is supported
         if (!mxClient.isBrowserSupported())
         {
            mxUtils.error('Browser is not supported!', 200, false);
         }
         else
         {
            // Creates the graph inside the given container
            let graph = new mxGraph(container);

            // Enables rubberband selection
            new mxRubberband(graph);

            // Gets the default parent for inserting new cells. This
            // is normally the first child of the root (ie. layer 0).
            let parent = graph.getDefaultParent();

            // Adds cells to the model in a single step
            graph.getModel().beginUpdate();
            try
            {
               var v1 = graph.insertVertex(parent, null,
                        'Hello,', 20, 20, 80, 30);
               var v2 = graph.insertVertex(parent, null,
                        'World!', 200, 150, 80, 30);
               var e1 = graph.insertEdge(parent, null, '', v1, v2);
            }
            finally
            {
               // Updates the display
               graph.getModel().endUpdate();
            }
         }
      };
   &lt;/script&gt;
&lt;/head&gt;

&lt;!-- Page passes the container for the graph to the program --&gt;
&lt;body onload=<em>&quot;main(document.getElementById('graphContainer'))&quot;</em>&gt;

   &lt;!-- Creates a container for the graph with a grid wallpaper --&gt;
   &lt;div id=<em>&quot;graphContainer&quot;</em>
      style=<em>&quot;overflow:hidden;width:321px;height:241px;background:url('editors/images/grid.gif')&quot;</em>&gt;
   &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

<p>Important concepts to note in this exercise are:</p>
<ul>
	<li>mxClient.js is a JavaScript file combining all of the
	JavaScript source code of mxGraph. When downloading from a web server,
	obtaining all the JavaScript as one file is much faster than as lots of
	separate files, due to the overhead of the requests/acknowledgements
	required for each file. The speed increase is usually at least x2,
	although it varies with the capacity of the server to have parallel
	sockets open with one client.</li>
	<li>The JavaScript code and its dependencies are all placed within
	the <em>head</em> element.</li>
	<li>Internet Explorer has, by default, security options enabled
	that cause a user prompt when attempting to run JavaScript from the
	local file system. This can be disabled in the options menu, but note
	that running from the local file system is not a deployment scenario of
	mxGraph, this would only happen during development.</li>
	<li>Your application can be written and linked into the
	application either within the HTML file, or in separate JavaScript
	source code that is linked into the html in the way the mxClient.js
	file is in the example.</li>
</ul>

<h2><a id="deployment"></a>mxGraph Deployment and Debugging</h2>

<p>There are two versions of the mxClient.js file, one for production use and
a second for development/debugging use. <em>javascript/src/js/mxClient.js</em> is
the production version and <em>javascript/debug/js/mxClient.js</em> is for
development. The first version has all linefeeds stripped to ensure the
file is the minimal size possible. This has the side-effect of breaking most
JavaScript debuggers. During development you are advised to use the debug
version, which has the linefeeds in, enabling debugging in the supported
browsers.</p>

<p>Both mxClient.js files are the entire JavaScript source to mxGraph,
with all of the whitespace and comments removed to reduce file size.
Whilst debugging, it is easier to use the individual source files if you
need to debug into the mxGraph library itself. The source code version of
mxGraph contains the full source in the source.zip file in the
<em>javascript/devel</em> directory. Unzipping this into the mxBasePath and removing
the load of the complete mxClient.js file enables easier debugging of mxGraph.
Note that the mxClient.js file in the source zip is a bootstrap file that
loads all the other JavaScript source code.</p>

<p>The download speed of the client source can be further improved
by compressing the code. All modern browsers support receiving and
uncompressing transmissions compressed at the server end and all good
web servers support detection of those browser that do not support it
and send the uncompressed version as a fallback.</p>

<p>For example, on the Apache web server there is a mod_deflate
module, details of its use can be found from a standard search. The
jgraph.com server uses this module and there have been no reports of
issues in any supported browser.</p>

<p>The use of compression reduces the mxClient.js file size down
from about 600KB to around 130KB. The difference is not noticed by the
user on most modern networks, but there might be situations where the
smaller version would be preferable.</p>

<br/>


<!-- ================================================================================= -->
<!-- in 3: everything has been integrated -->
<!-- ================================================================================= -->

